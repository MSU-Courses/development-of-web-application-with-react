# Интеграция REST API в React

## Почему мы говорим о REST API в контексте React?

Мы уже много говорили о том, что такое API и REST API, как они работают и зачем нужны. Но как это связано с React? Почему вообще стоит обсуждать REST API в курсе по фронтенду?

Давайте начнём с базового. React — это библиотека для создания пользовательских интерфейсов, то есть часть фронтенда. Вспомним, что такое фронтенд: это всё, что работает в браузере и отображается пользователю — HTML, CSS и JavaScript.

Когда вы открываете веб-приложение, браузер получает HTML и JS (в том числе и ваш React-код), которые он интерпретирует и отображает. Однако JavaScript в браузере работает в изолированной среде:

- Он не имеет доступа к файловой системе сервера;
- Он не может напрямую взаимодействовать с базой данных, потому, что находится у вас на браузере.

Именно поэтому нужен бэкенд — отдельное приложение, которое обрабатывает бизнес-логику, работает с базой данных и предоставляет API для обмена данными с фронтендом.

### Как это работает вместе?

Вернёмся к знакомой нам схеме:

- **Frontend**: Приложение, написанное на React, отображается в браузере пользователя. Оно отвечает за интерфейс и поведение на клиентской стороне.
- **Backend**: Серверное приложение, которое взаимодействует с базой данных и предоставляет REST API.

Чтобы связать фронтенд с бэкендом:

- React-приложение отправляет HTTP-запросы к REST API с помощью JavaScript, так как JavaScript в браузере умеет выполнять HTTP-запросы с использованием встроенных инструментов, таких как `fetch` [^2].
- Бэкенд обрабатывает запрос, взаимодействует с базой данных и возвращает данные, как правило, в формате JSON.
- Эти данные мы затем используем в компоненте React: отображаем список задач, профили пользователей, товары в магазине и т.д.

## Как фронтенд взаимодействует с API

Когда фронтенд-приложению (например, написанному на React) нужны данные или нужно отправить данные на сервер, оно делает HTTP-запрос к соответствующему API. В браузере JavaScript позволяет выполнять такие запросы асинхронно, не блокируя интерфейс. Рассмотрим два популярных способа делать запросы из фронтенда:

- `Fetch API` (встроенный в браузер) – современный стандарт для выполнения запросов. Метод `fetch()` возвращает обещание (Promise), которое позволит получить результат запроса, когда он придёт.
- `Axios` (внешняя библиотека) [^3] – популярная библиотека, упрощающая работу с запросами. `Axios` предоставляет удобные методы (`axios.get(...)`, `axios.post(...)` и т.д.), возвращающие Promise, и автоматически обрабатывает некоторые детали (например, преобразует JSON ответ в объект).

Оба подхода делают по сути одно и то же – отправляют HTTP-запрос и получают ответ – но синтаксис немного отличается.

### Пример использования Fetch API

Рассмотрим пример использования Fetch API и Axios.

#### Где взять API?

_Первый логичный вопрос_: где взять API, если у нас _нет собственного бэкенда_? Не переживайте — существует множество бесплатных API, созданных специально для тестирования и обучения. Один из самых популярных — это [JSONPlaceholder](https://jsonplaceholder.typicode.com). Это фейковый REST API, который предоставляет тестовые данные, имитируя работу реального сервера. Он идеально подходит для отработки навыков работы с HTTP-запросами в фронтенде.

Например, у JSONPlaceholder есть REST API для получения списка пользователей:

```
https://jsonplaceholder.typicode.com/users
```

Этот API возвращает список пользователей в формате JSON. Вот как может выглядеть пример ответа:

```json
[
  {
    "id": 1,
    "name": "Leanne Graham",
    "username": "Bret",
    "email": "Sincere@april.biz",
    "address": {
      "street": "Kulas Light",
      "suite": "Apt. 556",
      "city": "Gwenborough",
      "zipcode": "92998-3874",
      "geo": {
        "lat": "-37.3159",
        "lng": "81.1496"
      }
    },
    "phone": "1-770-736-8031 x56442",
    "website": "hildegard.org",
    "company": {
      "name": "Romaguera-Crona",
      "catchPhrase": "Multi-layered client-server neural-net",
      "bs": "harness real-time e-markets"
    }
  },
  {
    "id": 2,
    "name": "Ervin Howell",
    "username": "Antonette",
    "email": "Shanna@melissa.tv",
    "address": {
      "street": "Victor Plains",
      "suite": "Suite 879",
      "city": "Wisokyburgh",
      "zipcode": "90566-7771",
      "geo": {
        "lat": "-43.9509",
        "lng": "-34.4618"
      }
    },
    "phone": "010-692-6593 x09125",
    "website": "anastasia.net",
    "company": {
      "name": "Deckow-Crist",
      "catchPhrase": "Proactive didactic contingency",
      "bs": "synergize scalable supply-chains"
    }
  }
  // ...
]
```

Вы можете использовать этот API, чтобы тренироваться в написании HTTP-запросов и отображении данных в интерфейсе React-приложения.

#### Пример использования Fetch API

Для работы с API в браузере мы можем использовать встроенный метод `fetch()`. Он позволяет отправлять HTTP-запросы и обрабатывать ответы от сервера.

**Пример 1**. _Получение списка пользователей с помощью Fetch API_

```javascript
// Пример с Fetch API:
fetch('https://jsonplaceholder.typicode.com/users') // отправляем GET-запрос
  .then((response) => {
    if (!response.ok) {
      // response.ok === false означает, что ответ содержит ошибку (статус 4xx или 5xx)
      console.error('Ошибка:', response.status, response.statusText);
    }
    return response.json(); // преобразуем JSON в объект JavaScript
  })
  .then((data) => {
    console.log('Полученные данные:', data); // работаем с полученными данными
  })
  .catch((error) => {
    console.error('Произошла ошибка при запросе:', error);
  });
```

- `fetch()` работает асинхронно — это значит, что выполнение кода не блокируется и продолжается дальше, пока запрос обрабатывается. Когда сервер возвращает ответ, вызываются обработчики `.then()` или `.catch()`.
- Этот механизм основан на `Promise`, а в современных приложениях часто используется синтаксис `async/await` — более удобный и читаемый способ работы с асинхронным кодом.

> [!NOTE]
> Чтобы «познакомиться» с API, вы можете просто открыть соответствующий URL в браузере — например, https://jsonplaceholder.typicode.com/users. Браузер отобразит сырой JSON — это может выглядеть некрасиво, но очень полезно при отладке: вы сразу видите, какие именно данные возвращает сервер.

### Пример использования Axios

Как упоминалось ранее, **Axios** — это популярная библиотека для работы с HTTP-запросами. Она упрощает синтаксис по сравнению с `fetch()` и предоставляет ряд дополнительных удобств.

Для начала необходимо установить библиотеку в проект:

```bash
npm install axios
```

**Пример 2**. _Получение списка пользователей с помощью Axios_

```javascript
import axios from 'axios'; // импортируем библиотеку

// Пример с Axios:
axios
  .get('https://jsonplaceholder.typicode.com/users') // отправляем GET-запрос
  .then((response) => {
    console.log('Полученные данные:', response.data); // доступ к данным через response.data
  })
  .catch((error) => {
    console.error('Произошла ошибка при запросе:', error);
  });
```

Почему Axios может быть удобнее `fetch()`

- Автоматическое преобразование ответа в формат JSON — вам не нужно вручную вызывать `response.json()`.
- Упрощённая обработка ошибок — Axios автоматически определяет, была ли ошибка на стороне сервера или сети, и передаёт её в `catch()`.
- Поддержка отмены запросов, таймаутов, настройки заголовков и других полезных функций.
- Отлично работает с синтаксисом `async/await`, делая асинхронный код ещё чище и понятнее.

**Пример 3**. _Получение списка пользователей с помощью Axios и async/await_

```javascript
import axios from 'axios'; // импортируем библиотеку

async function fetchUsers() {
  try {
    const response = await axios.get('https://jsonplaceholder.typicode.com/users'); // отправляем GET-запрос
    console.log('Полученные данные:', response.data); // выводим полученные данные
  } catch (error) {
    console.error('Произошла ошибка при запросе:', error); // обрабатываем ошибку
  }
}

fetchUsers(); // вызываем функцию
```

- Такой синтаксис делает асинхронный код более линейным и читаемым, особенно при множестве последовательных операций.
- В отличие от `.then()` и `.catch()`, структура `try...catch` позволяет обрабатывать ошибки в привычном для JavaScript виде.

## Использование Rest API в React

Теперь, когда мы разобрались с основами REST API и HTTP-запросов, давайте посмотрим, как применить эти знания в React-приложении.

### Состояния загрузки, успеха и ошибки при работе с API

При взаимодействии с API на фронтенде очень важно правильно обрабатывать разные состояния. Пользователь не должен оставаться в неведении, что происходит после того, как приложение отправило запрос. Обычно выделяют три основных состояния:

- **Загрузка** (`loading`) — данные ещё не получены, запрос в процессе. В этом состоянии принято отображать индикатор загрузки или сообщение вроде "Загрузка...", чтобы пользователь понимал, что всё работает. Также можно использовать Skeleton Loader [^1] для более приятного UX.
- **Успех** (`success`) — данные успешно получены. В этом состоянии приложение отображает нужный контент: список, таблицу, профиль пользователя и т.д.
- **Ошибка** (`error`) — что-то пошло не так: сервер не отвечает, проблема с сетью, неправильный URL и т.д. Здесь важно корректно сообщить об ошибке: например, вывести сообщение "Не удалось загрузить данные" или предложить повторить попытку.

В React удобно управлять состояниями с помощью хуков `useState`. Обычно создают три отдельных состояния:

**Пример 4**. _Создание состояний для загрузки, успеха и ошибки_

```jsx
const [users, setUsers] = useState([]); // сами данные (например, список пользователей)
const [loading, setLoading] = useState(false); // флаг загрузки
const [error, setError] = useState(null); // сообщение об ошибке или null
```

Как это работает:

1. До запроса:
   - `loading = false` (ничего не загружается)
   - `error = null` (ошибок нет)
   - `users = []` (данных ещё нет)
2. Перед отправкой запроса:
   - `setLoading(true)` — показываем, что началась загрузка
   - `setError(null)` — сбрасываем возможную старую ошибку
3. Если запрос выполнен успешно:
   - `setUsers(data)` — сохраняем полученные данные
   - `setLoading(false)` — убираем индикатор загрузки
4. Если произошла ошибка:
   - `setError(error.message)` — сохраняем сообщение об ошибке
   - `setLoading(false)` — останавливаем состояние загрузки

### В какой момент делать запрос?

В зависимости от задачи, запросы к API в React-приложении можно выполнять в разное время, в зависимости от пользовательского сценария:

- При первом рендере компонента — например, с помощью хука `useEffect` с пустым массивом зависимостей. Это удобно, если данные нужны сразу при загрузке страницы.
- По действию пользователя — например, при нажатии на кнопку, или при отправке формы. Используется, когда данные нужно получить по запросу, а не заранее.
- При изменении состояния — например, при выборе категории или фильтрации. Это полезно, если данные зависят от другого состояния компонента.

#### Получение данных при первом рендере компонента

**Когда применяется?** Когда данные должны быть загружены сразу после отображения страницы. Например, при открытии профиля пользователя, списка задач, ленты новостей и т.д.

Для таких случаев используется хук `useEffect()`, который позволяет выполнять побочные эффекты в функциональных компонентах — в том числе, HTTP-запросы.

**\*Пример 5**. _Получение данных при первом рендере компонента_

```jsx
useEffect(() => {
  // Объявляем асинхронную функцию внутри useEffect
  const fetchUsers = async () => {
    try {
      setLoading(true); // начинаем загрузку
      setError(null); // очищаем прошлые ошибки

      const response = await axios.get('https://jsonplaceholder.typicode.com/users');
      setUsers(response.data); // сохраняем полученные данные
    } catch (err) {
      setError(err.message || 'Ошибка при загрузке данных'); // сохраняем текст ошибки
    } finally {
      setLoading(false); // отключаем индикатор загрузки
    }
  };

  fetchUsers(); // вызываем функцию
}, []); // пустой массив зависимостей — запрос выполнится один раз при монтировании
```

- `axios.get(...)` выполняет HTTP-запрос.
- Состояния `loading`, `error` и `users` управляют логикой отображения.
- Использован `async/await` для более читаемого кода.
- Ошибка и индикатор загрузки обрабатываются отдельно, что улучшает UX.
- `finally` гарантирует, что индикатор загрузки будет отключён в любом случае, даже если произошла ошибка.

#### Получение данных по действию пользователя

**Когда применяется?** Когда данные нужно загрузить по инициативе пользователя. _Например_: при нажатии на кнопку «Загрузить ещё», при отправке формы, выборе фильтра и т.д.

**Пример 6**. _Отправка POST-запроса для создания нового пользователя_

```jsx
const handleCreateUser = (user) => {
  setError(null); // очищаем предыдущие ошибки

  axios
    .post('https://jsonplaceholder.typicode.com/users', user) // отправляем POST-запрос
    .then((response) => {
      // добавляем нового пользователя в конец списка
      setUsers((prevUsers) => [...prevUsers, response.data]);
    })
    .catch((err) => {
      // сохраняем сообщение об ошибке
      setError(err.message || 'Ошибка при создании пользователя');
    });
};
```

- Вторым параметром в `axios.post()` передаётся тело запроса — в данном случае, объект с данными нового пользователя.
- Axios автоматически преобразует объект в JSON, устанавливает нужные заголовки `(Content-Type: application/json)` и отправляет запрос на сервер.
- Сервер обычно возвращает созданный объект в ответе, и мы добавляем его к текущему состоянию (в данном случае, к списку пользователей).

### Пример: получение и отображение списка пользователей из публичного API

Пора объединить всё, что мы узнали, и применить это на практике.

В качестве примера возьмём публичный REST API JSONPlaceholder, который мы уже упоминали ранее. Один из его эндпоинтов — `/users` — возвращает список пользователей. **Наша задача**: получить этот список из React-приложения и отобразить его на странице.

Допустим, мы создаём компонент `UsersList`, который при загрузке страницы автоматически загружает и отображает список пользователей.

#### Этапы реализации

1. Отправляем запрос при загрузке компонента — с помощью `useEffect()` с пустым массивом зависимостей.
2. Сохраняем данные в состояние (или ошибку — при неудачном запросе) — с помощью трёх переменных состояния: `users`, `loading`, `error`.
3. В зависимости от состояния отображаем разный UI: индикатор загрузки, сообщение об ошибке или список пользователей.

#### Реализация компонента

**Пример 7**. _Компонент UsersList_

```jsx
import React, { useState, useEffect } from 'react';

function UsersList() {
  const [users, setUsers] = useState([]); // данные пользователей
  const [loading, setLoading] = useState(false); // флаг загрузки
  const [error, setError] = useState(null); // сообщение об ошибке

  useEffect(() => {
    setLoading(true);
    setError(null);

    fetch('https://jsonplaceholder.typicode.com/users')
      .then((response) => {
        if (!response.ok) {
          throw new Error(`Ошибка ${response.status}`);
        }
        return response.json();
      })
      .then((data) => {
        setUsers(data);
        setLoading(false);
      })
      .catch((err) => {
        console.error('Ошибка при получении пользователей:', err);
        setError(err);
        setLoading(false);
      });
  }, []); // эффект выполнится только один раз — при монтировании компонента

  // Условный рендеринг в зависимости от текущего состояния
  if (loading) {
    return <p>Загрузка данных...</p>;
  }

  if (error) {
    return <p>Ошибка: не удалось загрузить пользователей.</p>;
  }

  return (
    <ul>
      {users.map((user) => (
        <li key={user.id}>
          {user.name} — {user.email}
        </li>
      ))}
    </ul>
  );
}

export default UsersList;
```

В данном примере:

- В начале мы импортируем `useState` и `useEffect` из `React`. Затем объявляем три состояния:
  - `users` — массив пользователей.
  - `loading` — булевый флаг, указывающий, происходит ли загрузка.
  - `error` — текст ошибки или null, если её нет.
- При монтировании компонента (`[]` в зависимостях) запускается `fetch`. Необходимо:
  - Поставить `loading` в `true`, сбросить ошибку.
  - Выполинть запрос к API.
  - Если ответ успешен — парсить JSON и сохранить данные в `users`.
  - Если произошла ошибка — сохранить её в `error`.
  - В обоих случаях после завершения запроса выключаем индикатор загрузки.
- Условный рендеринг
  - Пока `loading = true`, показываем сообщение «Загрузка данных...».
  - Если `error !== null`, отображаем сообщение об ошибке.
  - Если данные успешно загружены, выводим список `<ul>` с именами и email пользователей.

#### Что мы реализовали?

- Отправку HTTP-запроса (GET) к удалённому REST API.
- Обработку ответа и преобразование данных из формата JSON.
- Сохранение данных в состоянии React-компонента.
- Обновление интерфейса с учётом состояний загрузки и ошибок.

### Структурирование кода

Во многих проектах рекомендуется отделять логику работы с API от компонентов. Это улучшает читаемость, облегчает сопровождение и позволяет переиспользовать код в разных частях приложения.

#### Шаг 1: создаём отдельный модуль API

Создайте директорию `api` внутри папки `src`, а в ней файл `users.js`.

```
src/
├── api/
│   └── users.js
```

#### Шаг 2: описываем функции работы с API

В файле `src/api/users.js` создадим отдельные функции для операций с пользователями:

1. Создадим директорию `api` в директории `src` и файл `users.js` внутри неё.
2. В этом файле создадим функцию `fetchUsers`, которая будет выполнять запрос к API и возвращать данные.

   ```javascript
   // src/api/users.js
   import axios from 'axios';

   const BASE_URL = 'https://jsonplaceholder.typicode.com/users';

   export const fetchUsers = async () => {
     const response = await axios.get(BASE_URL);
     return response.data;
   };

   export const createUser = async (user) => {
     const response = await axios.post(BASE_URL, user);
     return response.data;
   };

   export const updateUser = async (userId, user) => {
     const response = await axios.put(`${BASE_URL}/${userId}`, user);
     return response.data;
   };

   // ...
   ```

   Благодаря такому подходу, мы можем централизованно управлять запросами и при необходимости легко менять базовый URL или добавлять обработку ошибок.

#### Шаг 3: используем API-функции в компоненте `UsersList`

Теперь можно использовать `fetchUsers()` из модуля API в компоненте. Обратите внимание, что мы импортируем отдельные функции, а не весь объект

```jsx
// src/components/UsersList.jsx
import React, { useState, useEffect } from 'react';
import { fetchUsers } from '../api/users'; // импорт функции из api

function UsersList() {
  const [users, setUsers] = useState([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  useEffect(() => {
    const getUsers = async () => {
      try {
        setLoading(true);
        setError(null);
        const data = await fetchUsers();
        setUsers(data);
      } catch (err) {
        console.error('Ошибка при получении пользователей:', err);
        setError(err.message || 'Не удалось загрузить пользователей');
      } finally {
        setLoading(false);
      }
    };

    getUsers();
  }, []);

  if (loading) {
    return <p>Загрузка данных...</p>;
  }

  if (error) {
    return <p>Ошибка: {error}</p>;
  }

  return (
    <ul>
      {users.map((user) => (
        <li key={user.id}>
          {user.name} — {user.email}
        </li>
      ))}
    </ul>
  );
}

export default UsersList;
```

**Преимущества структурирования API-логики**:

- Чистый и читаемый код компонентов.
- Возможность переиспользования API-функций в других местах.
- Упрощённая отладка и тестирование логики взаимодействия с сервером.
  Вот краткий **Recap** для главы **«REST API во фронтенд-приложениях React»**:

## Recap: Интеграция REST API в React

1. **React = UI**, но данные для интерфейса нужно откуда-то брать — и чаще всего из **бэкенда через API**.  
   JavaScript в браузере не имеет доступа к базе данных, а значит, нужен посредник — REST API.

2. Данные с бэкенда получаем с помощью **HTTP-запросов (GET, POST, PUT, DELETE)**.  
   Делать запросы можно через:

   - `fetch()` — встроенный инструмент браузера;
   - `axios` — удобная внешняя библиотека.

3. В React важно **обрабатывать состояния загрузки, успеха и ошибки**:

   - до запроса: `loading = false`, `error = null`;
   - при загрузке: `loading = true`;
   - после: либо сохраняем `data`, либо показываем `error`.

4. Запросы часто выполняются:

   - при первом рендере (в `useEffect`);
   - по действию пользователя (нажатие кнопки и т.д.).

5. **Вынесите логику работы с API в отдельные модули** (`/api/users.js`) — это упрощает структуру проекта и улучшает читаемость.

[^1]: _React Loading Skeleton_. npmjs.com [online resource]. Available at: https://www.npmjs.com/package/react-loading-skeleton
[^2]: _Fetch API_. mdn [online resource]. Available at: https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API
[^3]: _Getting Started_. axios-http.com [online resource]. Available at: https://axios-http.com/docs/intro
