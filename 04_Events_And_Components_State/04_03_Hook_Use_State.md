# Хуки в React. Хук `useState`

Перед тем как углубиться в дальнейшее изучение React, важно разобраться, что такое хуки (hooks) и как они используются. Поскольку для управления состоянием компонента в функциональных компонентах необходимо применять хуки, их понимание является ключевым.

## Что такое хуки?

**Хуки (hooks)** — **это специальные функции в React**, которые позволяют добавлять дополнительный функционал в обычные (функциональные) компоненты. До появления хуков можно было управлять состоянием и работать с компонентами только в классовых компонентах. С хуками теперь можно делать это и в функциональных компонентах, что делает код проще и понятнее [^1].

Простыми словами, **хуки** помогают компонентам "запоминать" данные и реагировать на изменения без использования сложных конструкций.

Первый хук, с которым стоит познакомиться, — это `useState`. Он позволяет функциональным компонентам добавлять **"состояние"** и изменять его в процессе работы.

## Проблема с изменением состояния

**Рассмотрим ситуацию**: нам нужно создать счётчик, который увеличивается на 1 при каждом клике на кнопку. Попробуем использовать обычную переменную `count` и функцию `increment`, которая изменяет её значение:

**Пример 1**. Счётчик без использования `useState`:

```jsx
function Counter() {
  let count = 0;

  function increment() {
    count += 1;
  }

  return (
    <div>
      <p>Счётчик: {count}</p>
      <button onClick={increment}>Увеличить</button>
    </div>
  );
}
```

На первый взгляд, код кажется правильным, но если нажимать на кнопку, счётчик не обновляется. Почему? Дело в том, что React не отслеживает изменения переменной `count` и не понимает, что компонент нужно перерисовать.

**Напомним, что React используется для создания SPA, и мы не хотим, чтобы пользователь обновлял страницу для отображения изменений (!)**. Поэтому важно, чтобы React самостоятельно отслеживал изменения и автоматически обновлял интерфейс.

## Использование хука `useState`

Так как значение счётчика — это состояние компонента, и мы хотим, чтобы React обновлял (перересовывал) интерфейс при изменении этого значения, воспользуемся хуком `useState`.

Синтаксис `useState`:

```jsx
const [state, setState] = useState(initialState);
```

- `state` — переменная, хранящая текущее значение состояния.
- `setState` — функция, позволяющая изменить состояние (_сеттер_).
- `initialState` — начальное значение состояния.

Чтобы изменить состояние, нельзя напрямую изменять `state`. Вместо этого используется `setState`, который обновляет его и заставляет React перерисовать компонент.

```jsx
setState(5);
// теперь переменная state равна 5
```

Таким образом, с помощью хука `useState` и функции-сеттера (`setState(...)`), отвечающей за обновление состояния, мы вмешиваемся в этот процесс и даём React сигнал о необходимости перерисовки интерфейса.

> [!IMPORTANT]
> При изменении `состояния (state)` или `свойства (props)` React заново вызывает функцию компонента, обновляя интерфейс в соответствии с новыми данными. **Этот процесс часто называют перерисовкой компонента**. Если компонент использует `useState`, React запоминает значение переменной и следит за её изменениями.

Следовательно, если мы хотим, чтобы React отслеживал изменения переменных и автоматически обновлял интерфейс, необходимо использовать хук `useState`. Фактически, мы указываем React сохранить значение переменной и реагировать на его изменения перерисовывая компонент.

### Реализация счётчика с `useState`

Теперь переделаем наш компонент, используя `useState`.

**Пример 2**. Счётчик с использованием `useState`.

```jsx
import React, { useState } from "react";

function Counter() {
  const [count, setCount] = useState(0);

  function increment() {
    // count = count + 1 - не будет работать!

    // Берем прошлое значение count и увеличиваем на 1
    // Допустим count = 0, тогда count + 1 = 1
    setCount(count + 1); // Обновляем состояние
  }

  return (
    <div>
      <p>Счётчик: {count}</p>
      <button onClick={increment}>Увеличить</button>
    </div>
  );
}
```

Теперь **при каждом клике на кнопку**:

- Состояние `count` увеличивается на 1.
- React замечает изменение и перерисовывает компонент (вызывает функцию `Counter` ещё раз и обновляет интерфейс).

> [!NOTE]
> Данный процесс называется **реактивностью** — это способность компонента отслеживать изменения состояния и автоматически обновлять интерфейс. В первом примере компонент не был реактивным, поскольку React не отслеживал изменения переменной `count`. Во втором примере, благодаря использованию `useState`, компонент стал реактивным.

### Множество состояний в компоненте

Компонент может содержать несколько состояний, каждое из которых управляется отдельным хуком `useState`. Рассмотрим пример, в котором у нас есть массив постов (`posts.js`), и мы хотим создать слайдер, который будет последовательно отображать посты. Дополнительно предусмотрим возможность отображения полного описания поста по нажатию на кнопку.

#### Исходные данные (массив постов)

```js
// posts.js

export const posts = [
  {
    title: "New Year",
    content: "Happy New Year 2025!",
  },
  {
    title: "Saint Patrick's Day",
    content:
      "Saint Patrick's Day is a cultural and religious holiday celebrated on 17 March.",
  },
];
```

#### Компонент `Slider`

```jsx
// Slider.jsx
import React from "react";

import { posts } from "./posts";

function Slider() {
  // Индекс текущего поста
  // В начале показываем первый пост (индекс 0)
  const [index, setCurrentIndex] = React.useState(0);

  // Состояние для отображения полного описания поста
  // По умолчанию не показываем полное описание (false)
  const [isDescription, setIsDescription] = React.useState(false);

  // Функция для показа полного описания
  function showDescription() {
    // Меняем состояние на противоположное
    // Если isDescription было false, то станет true
    // Если isDescription было true, то станет false
    setIsDescription(!isDescription);
  }

  // Функция для перехода к следующему посту
  function nextPost() {
    // Если индекс меньше, чем количество постов
    if (index < posts.length - 1) {
      // Берем текущий индекс и увеличиваем на 1
      // Переходим к следующему посту
      setCurrentIndex(index + 1);
    }
  }

  // Функция для перехода к предыдущему посту
  function previosPost() {
    // Если индекс больше 0
    if (index > 0) {
      // Берем текущий индекс и уменьшаем на 1
      // Переходим к предыдущему посту
      setCurrentIndex(index - 1);
    }
  }

  // Текущий пост
  // При изменении индекса будет меняться и текущий пост
  let currentPost = posts[index];

  return (
    <div>
      <h2>{currentPost.title}</h2>
      <div>
        <p>
          ({index + 1} of {posts.length})
        </p>
      </div>
      {/* Если isDescription равно true, то показываем кнопку */}
      <button onClick={showDescription}>
        {isDescription ? "Hide" : "Show"} description
      </button>
      <p>{isDescription && currentPost.content}</p>
      <button onClick={nextPost}>Next post</button>
      <button onClick={previosPost}>Previous post</button>
    </div>
  );
}

export default Slider;
```

Допустим, при клике на кнопку **"Next Post"**:

1. Вызывается функция `nextPost`.
2. Внутри функции выполняется проверка: если текущий индекс (`index`) **меньше** количества постов минус один (`posts.length - 1`), то компонент обновляет индекс поста, увеличивая его на 1.
3. Вызывается `setCurrentIndex(index + 1)`, что обновляет состояние `index`.
4. Так как состояние изменилось, React **перерисовывает компонент**, вызывая его функцию заново.
5. В процессе нового вызова `Slider()` переменная `currentPost` пересчитывается и теперь указывает на новый пост из массива `posts`.
6. Обновленный интерфейс отображает **новый заголовок и описание** поста.
7. Счётчик (`{index + 1} of {posts.length}`) обновляется, отражая текущий номер поста.

Аналогичный процесс происходит при нажатии на **"Previous Post"**, но индекс уменьшается (`setCurrentIndex(index - 1)`), переключая слайдер на предыдущий пост.

### Состояние как снимок данных

Есть один важный момент, который не всегда сразу понятен, но играет ключевую роль в работе `useState`.

Когда мы изменяем состояние с помощью `setState`, React **не обновляет значение переменной мгновенно**. Вместо этого он создаёт **новый снимок** состояния и запоминает, что компонент нужно обновить. Например, если у нас был `Counter` с `count = 0`, после вызова `setState(count + 1)` создаётся новый `Counter` с `count = 1`.

То есть React сначала завершает выполнение текущей функции, а затем выполняет повторный рендеринг с обновлённым состоянием.

**Пример 3**. Подробное объяснение работы `useState`:

```jsx
import { useState } from "react";

function Counter() {
  const [count, setCount] = useState(0);

  function increment() {
    setCount(count + 1); // count = count + 1

    // Здесь count не обновится мгновенно
    // Поэтому console.log(count) выведет старое значение
    console.log(count); // 0 (если это первый клик)
  }

  return (
    <div>
      <p>Счётчик: {count}</p>
      <button onClick={increment}>Увеличить</button>
    </div>
  );
}
```

**Почему так происходит?**

1.  React обновляет состояние не сразу, а запоминает изменения и выполняет ререндер позже.
2.  В текущем вызове функции `count` остаётся неизменным.
3.  После ререндера компонента новое значение `count` становится доступным.

Таким образом, состояние в React работает как **снимок данных**, который обновляется при каждом новом рендере.

[^1]: _State: A Component's Memory_. react. dev [online resource]. URL: https://react.dev/learn/state-a-components-memory
