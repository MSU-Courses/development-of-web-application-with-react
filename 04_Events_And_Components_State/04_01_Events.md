# Управление событиями в React

При разработке веб-приложений часто требуется обрабатывать события. _Например_, пользователь нажал кнопку, отправил форму или навёл курсор на элемент — всё это требует отклика со стороны приложения.

**Событие** — это любое действие в браузере, например, нажатие клавиши или загрузка страницы. Чтобы приложение работало корректно, важно уметь на них реагировать и выполнять соответствующие действия, то есть реагировать на события. _Например_, при нажатии на кнопку можно отправить сообщение, а при наведении на элемент — показать дополнительную информацию.

Если рассматривать **"действие"** в контексте программирования, его можно определить как вызов **функции**. Проще говоря, действие — это выполнение определённой функции в ответ на событие.

> [!NOTE]  
> Ранее наше приложение просто отображало данные. Теперь мы добавим взаимодействие с пользователем с помощью событий.

## События в javascript

В JavaScript существуют различные события, которые позволяют реагировать на действия пользователя. Вот некоторые из них:

- `click` — срабатывает при клике на элементе.
- `change` — возникает при изменении значения элемента.
- `mouseover` — происходит при наведении курсора на элемент.
- `keydown` — срабатывает при нажатии клавиши на клавиатуре.
- `submit` — активируется при отправке формы.
- ...и многие другие.

Для обработки событий чаще всего используют метод `addEventListener`, который привязывает обработчик события к элементу.

**Пример 1.** _Обработка события `click`_

```javascript
const button = document.querySelector("#button");

button.addEventListener("click", function () {
  console.log("Кнопка нажата!");
});
```

```html
<button id="button">Нажми меня</button>
```

При клике на кнопку в консоль будет выведено сообщение **"Кнопка нажата!"**.

## Обработка событий в React

В React обработка событий происходит схожим образом, но вместо метода `addEventListener` чаще всего используются **атрибуты JSX**. Однако в некоторых случаях `addEventListener` тоже может пригодиться — мы разберём такие ситуации позже.

В React события обрабатываются с помощью атрибутов JSX, которые начинаются с `on` [^1]. Например, чтобы обработать событие `click`, используется атрибут `onClick`.

### Основы обработки событий

**Пример 2.** _Обработка события `click` в React_

В следующем примере кнопка просто отображается, но при нажатии ничего не происходит, так как отсутствует обработчик события:

```jsx
function App() {
  return <button>Нажми меня</button>;
}
```

Добавим обработку события `click`:

```jsx
function App() {
  const handleClick = () => {
    console.log("Кнопка нажата!");
  };

  return <button onClick={handleClick}>Нажми меня</button>;
}
```

Теперь при клике на кнопку в консоль будет выводиться сообщение **"Кнопка нажата!"**.

Здесь мы:

- Создали функцию `handleClick` внутри компонента `App`.
- Передали её в атрибут `onClick` кнопки.
- Обработчик `handleClick` вызывается автоматически при нажатии на кнопку.

> [!NOTE]  
> Функция, которая обрабатывает событие, называется обработчиком события (_event handler_). В данном случае `handleClick` — это обработчик события `click`.

Функции-обработчики событий:

1. Обычно объявляются внутри компонента, чтобы иметь доступ к другим переменным и функциям.
2. Начинаются с префикса `handle`, за которым следует название события (например, `onClick={handleClick}`, `onClick={handleChange}`, `onClick={handleMouseEnter}`).

### Использование inline-функций

Мы также можем передавать функцию напрямую в атрибут `onClick`, не создавая отдельную переменную.

**Пример 3.** _Обработка события `click` с использованием inline-функции_

```jsx
function App() {
  return (
    <button
      onClick={function handleClick() {
        console.log("Кнопка нажата!");
      }}
    >
      Нажми меня
    </button>
  );
}
```

Либо можно использовать стрелочную функцию:

**Пример 4.** _Обработка события `click` с использованием стрелочной функции_

```jsx
function App() {
  return (
    <button onClick={() => console.log("Кнопка нажата!")}>Нажми меня</button>
  );
}
```

### Частые ошибки при работе с событиями

Одна из распространённых ошибок у начинающих разработчиков — вызов функции внутри атрибута события. Например:

```jsx
function App() {
  const handleClick = () => {
    console.log("Кнопка нажата!");
  };

  return <button onClick={handleClick()}>Нажми меня</button>;
}
```

В этом случае `handleClick()` выполнится сразу при рендере компонента, а в `onClick` попадёт результат её выполнения (в данном случае `undefined`). В итоге обработчик не сработает при нажатии на кнопку.

Чтобы избежать этой ошибки, нужно передавать только ссылку на функцию, а не результат её вызова:

| ✅ Правильно (передача функции)                          | ❌ Ошибка (вызов функции)                          |
| -------------------------------------------------------- | -------------------------------------------------- |
| `<button onClick={handleClick}></button>`                | `<button onClick={handleClick}></button>`          |
| `<button onClick={() => console.log("hello")}></button>` | `<button onClick={console.log("hello")}></button>` |

> [!WARNING]
> В JSX обработчики событий передаются как ссылки на функции. Если поставить круглые скобки (), функция выполнится сразу при рендере.

### Передача параметров в обработчик события

Иногда необходимо передавать параметры в обработчик события, например, передать идентификатор элемента при клике.

**Пример 5.** _Передача параметров в обработчик события_

```jsx
function App() {
  const handleClick = (id) => {
    console.log(`Кнопка с id ${id} нажата!`);
  };

  return <button onClick={() => handleClick(1)}>Нажми меня</button>;
}
```

В этом примере при клике на кнопку в консоль выведется сообщение **"Кнопка с id 1 нажата!"**.

Напомним, если вызвать функцию в `onClick` напрямую, она выполнится сразу при рендере компонента:

```jsx
// ❌ Ошибка: handleClick(1) выполнится сразу при рендере, а в onClick попадёт undefined
<button onClick={handleClick(1)}>Нажми меня</button>
```

### Передача обработчика событий через `props`

Во многих случаях обработчик событий передаётся в дочерний компонент через `props`, чтобы родительский компонент мог управлять его поведением. Это особенно полезно, если несколько компонентов должны использовать один и тот же обработчик.

Рассмотрим пример, в котором кнопка выполняет действие, переданное из родительского компонента.

**Пример 6.** _Передача обработчика события через `props`_

```jsx
function MessageButton({ onClick, label }) {
  return <button onClick={onClick}>{label}</button>;
}

function App() {
  const handleClickA = () => {
    console.log("Кнопка A нажата!");
  };

  const handleClickB = () => {
    console.log("Кнопка B нажата!");
  };

  return (
    <div>
      <MessageButton onClick={handleClickA} label="Нажми A" />
      <MessageButton onClick={handleClickB} label="Нажми B" />
    </div>
  );
}

export default App;
```

**В данном примере:**

1. **Компонент `MessageButton`** принимает два `props`:
   - `onClick` — обработчик события, переданный из родителя.
   - `label` — текст на кнопке.
2. **Обработчик `onClick`** привязывается к кнопке `<button>` внутри `MessageButton`.
3. **В родительском компоненте `App`** созданы две функции-обработчика:
   - `handleClickA`, который выводит в консоль `"Кнопка A нажата!"`.
   - `handleClickB`, который выводит в консоль `"Кнопка B нажата!"`.
4. **Кнопки вызывают свои обработчики при клике**, что позволяет управлять их поведением из `App`.

Рассмотрим более продвинутый пример, в котором компонент `Product` принимает параметр `name` и обработчик события `onAddToCart`. При клике на кнопку **"Добавить в корзину"** вызывается обработчик, который добавляет товар в корзину.

**Пример 7.** _Передача параметров в обработчик события_

```jsx
function Product({ name, onAddToCart }) {
  return (
    <div>
      <span>{name}</span>
      <button onClick={() => onAddToCart(name)}>Добавить в корзину</button>
    </div>
  );
}

function App() {
  const handleAddToCart = (productName) => {
    console.log(`Товар "${productName}" добавлен в корзину`);
    // Здесь можно добавить логику добавления товара в корзину
  };

  return (
    <div>
      <h2>Список товаров</h2>
      <Product name="Ноутбук" onAddToCart={handleAddToCart} />
      <Product name="Смартфон" onAddToCart={handleAddToCart} />
      <Product name="Наушники" onAddToCart={handleAddToCart} />
    </div>
  );
}

export default App;
```

**В данном примере:**

1. **Компонент `Product`**
   - Получает `name` (название товара).
   - Получает `onAddToCart`, который будет вызван при клике.
2. **Компонент `App`**
   - Определяет `handleAddToCart`, принимающий название товара и выводящий его в консоль.
   - Передаёт `handleAddToCart` в три экземпляра `Product`.
3. **В кнопке "Добавить в корзину"**
   - Используется функция `onClick={() => onAddToCart(name)}`, чтобы передать `name` в `handleAddToCart`.

### Получение события

Когда происходит событие, мы можем получить подробную информацию о нём, например:

- Какой элемент вызвал событие.
- Какие клавиши были нажаты.
- Какие координаты мыши были на экране.
- Какие данные были в input при событии `onChange`.
- и многое другое.

#### Как это работает на чистом JavaScript

В чистом JavaScript информация о событии передаётся через объект `event`:

```javascript
const button = document.querySelector("#button");

button.addEventListener("click", function (event) {
  console.log(event.target); // Элемент, на котором произошло событие
});
```

#### Как это работает в React

В React, как и на чистом JS, объект события автоматически передаётся в функцию-обработчи

```jsx
function handleClick(event) {
  console.log(event.target); // Элемент, на котором произошло событие
}

function App() {
  return <button onClick={handleClick}>Нажми меня</button>;
}
```

Любая функция, переданная в атрибут события, получает объект события в качестве аргумента. В этом объекте содержится информация о событии, например:

- `event.target` — элемент, на котором произошло событие.
- `event.type` — тип события (например, `"click"`, `"keydown"`).
- `event.clientX`, `event.clientY` — координаты курсора при клике.
- `event.target.value` — значение элемента формы (например, `input`).

Полный список свойств можно найти в справочнике MDN: https://developer.mozilla.org/en-US/docs/Web/API/Event.

### Передача параметров вместе с событием

Иногда в обработчик события нужно передать **дополнительные параметры**, _например_, идентификатор товара при нажатии на кнопку "Добавить в корзину".

**Пример 8.** _Передача параметров вместе с событием_

```jsx
function Product({ name, id, onAddToCart }) {
  return (
    <div>
      <span>{name}</span>
      <button onClick={(event) => onAddToCart(id, event)}>
        Добавить в корзину
      </button>
    </div>
  );
}

function App() {
  const handleAddToCart = (productId, event) => {
    console.log(`Товар с ID ${productId} добавлен в корзину`);
    console.log("Элемент кнопки:", event.target);
  };

  return (
    <div>
      <h2>Список товаров</h2>
      <Product id={101} name="Ноутбук" onAddToCart={handleAddToCart} />
      <Product id={102} name="Смартфон" onAddToCart={handleAddToCart} />
      <Product id={103} name="Наушники" onAddToCart={handleAddToCart} />
    </div>
  );
}

export default App;
```

**В данном примере**:

1. Компонент `Product` принимает `id` товара и обработчик `onAddToCart`.
2. При клике на кнопку вызывается `onAddToCart(id, event)`, передавая идентификатор товара и объект события.
3. Обработчик `handleAddToCart` принимает `productId` и `event`, затем выводит в консоль **ID товара** и **нажатую кнопку**.

### Когда нужно передавать объект события (`event`)?

Ряд ситуаций, когда передача объекта события (`event`) в обработчик события может быть полезной:

1. Для работы с элементом, на котором произошло событие
   - Доступ к `event.target` (например, изменение стиля кнопки).
2. Чтобы отменить стандартное поведение элемента
   - Использование `event.preventDefault()` (например, предотвращение отправки формы).
3. При обработке событий клавиатуры
   - Получение `event.key` для определения нажатой клавиши.
4. При работе с `input` и `textarea`
   - Получение `event.target.value` для получения значения элемента.
5. При работе с всплытием (bubbling) и перехватом (capturing) событий
   - Использование `event.stopPropagation()` для предотвращения всплытия события.
6. и другие случаи.

> [!NOTE]
> Если обработчик не использует свойства event, передавать его не нужно.

[^1]: _Responding to Events_. react.dev [online resource]. Available at: https://react.dev/learn/responding-to-events
