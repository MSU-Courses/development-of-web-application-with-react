# Жизненный цикл компонента и хук `useEffect`

## Аналогия с реальным миром

Представьте себе человека. Вы наверняка знакомы с понятием "жизненный цикл". Проще говоря, это этапы, через которые проходит человек от рождения до смерти: рождение, взросление, обучение, работа, выход на пенсию и, в конечном итоге, смерть. Однако жизненный цикл присущ не только людям, но и многим другим объектам, например, продуктам питания или автомобилям. В глобальном смысле, жизненный цикл человека можно разделить на три основные стадии: _рождение, развитие (включающее обучение и трудовую деятельность) и завершение_.

## Жизненный цикл компонента в React

Как и у человека, у компонента также есть жизненный цикл.

**Жизненный цикл компонента** — это последовательность этапов, которые он проходит от создания до удаления. В React он включает три основных стадии [^1]:

- **Создание (монтирование) (mounting)**
- **Обновление (updating)**
- **Удаление (размонтирование) (unmounting)**

Компонент проходит эти этапы в зависимости от выполняемых над ним операций.

Рассмотрим компонент `Counter`.

```jsx
import React, { useState } from 'react';

function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Счетчик: {count}</p>
      <button onClick={() => setCount(count + 1)}>Добавить 1</button>
    </div>
  );
}
```

Компонент `Counter` проходит следующие этапы жизненного цикла:

- Когда компонент создается и добавляется в DOM, он проходит этап **монтирования**.
- Когда пользователь нажимает на кнопку **"Добавить 1"**, компонент обновляется и проходит этап **обновления**. _Данный этап происходит каждый раз, когда пользователь нажимает на кнопку_.
- Когда пользователь переходит на другую страницу или закрывает вкладку (_компонент исчезает со страницы_), компонент удаляется из DOM и проходит этап **размонтирования**.

## Хук `useEffect`

Для отслеживания и управления жизненным циклом компонента в React (_> 16.8_) используется хук `useEffect`. Этот хук позволяет выполнять побочные эффекты в функциональных компонентах.

> [!TIP]
>  **Побочные эффекты** — это любые действия, которые необходимо выполнить в процессе работы приложения, например, загрузка данных, обновление DOM или подписка на события.

Синтаксис хука `useEffect`:

```jsx
import { useEffect } from 'react';

useEffect(
  () => {
    // Логика побочного эффекта

    return () => {
      // Очистка побочного эффекта
    };
  },
  [
    /* Зависимости */
  ],
);
```

На первый взгляд, `useEffect` может показаться сложным, но на самом деле он очень прост в использовании. Все, что вам нужно сделать, это передать функцию в качестве аргумента, и React выполнит ее в нужный момент.

### Создание компонента (монтирование)

**Когда происходит монтирование?**. Когда компонент добавляется в DOM. Простыми словами, когда все HTML-элементы компонента отображаются на экране.

**Создание компонента** — это начальный этап его жизненного цикла, на котором он добавляется в DOM. В этот момент можно выполнить определенные действия, _например_, настроить таймер, подписаться на события или вывести сообщение в консоль. Чтобы React выполнил код сразу после появления компонента, используют хук useEffect с пустым массивом зависимостей `[]`. Это гарантирует, что эффект сработает только один раз.

**Пример 1**. _Вывод сообщения при монтировании компонента_

```jsx
import { useEffect } from 'react';

function App() {
  useEffect(() => {
    // Этот код выполнится один раз после появления компонента
    console.log('Компонент появился на экране');
  }, []);

  return <h1>Привет, мир!</h1>;
}
```

**В примере выше происходит следующее**:

- Компонент рендерится и отображает заголовок "Привет, мир!".
- После монтирования выполняется useEffect, который выводит в консоль **"Компонент появился на экране!"**.

> [!TIP]
> В `useEffect` можно передавать как стрелочную, так и именованную функцию.

### Обновление компонента

**Когда происходит обновление?**. Когда компонент обновляется в результате изменения: состояния (_state_), пропсов (_props_) или контекста.

Чтобы реагировать на такие изменения, в `useEffect` передается массив зависимостей. Если одно из значений в этом массиве изменится, React вызовет `useEffect` заново.

**Пример 2**. _Обновление компонента при изменении состояния_

```jsx
import React, { useState, useEffect } from 'react';

function Counter() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    console.log(`Счетчик обновился: ${count}`);
  }, [count]); // useEffect выполняется при каждом изменении count

  return (
    <div>
      <p>Счетчик: {count}</p>
      <button onClick={() => setCount(count + 1)}>Добавить 1</button>
    </div>
  );
}

export default Counter;
```

**В примере выше происходит следующее**:

1. Когда пользователь нажимает кнопку, `count` увеличивается.
2. React перерисовывает компонент.
3. Так как `count` изменился, `useEffect` снова выполняется и пишет **"Счетчик обновился: X"** в консоль.

Даже если `useEffect` настроен на выполнение только при изменении `count`, он также срабатывает при первом рендере.

Если пользователь нажмет кнопку четыре раза, в консоли появится:

```cpp
Счетчик обновился: 0 // Первый рендер
Счетчик обновился: 1 // Первое обновление
Счетчик обновился: 2 // Второе обновление
Счетчик обновился: 3 // Третье обновление
Счетчик обновился: 4 // Четвертое обновление
```

### Удаление компонента (размонтирование)

**Когда происходит размонтирование?**. Когда компонент удаляется из DOM, когда он больше не нужен и перестает отображаться на экране.

Иногда, при _'скрытии'_ компонента полезно "убрать за собой" (_например_, остановить таймер или удалить ненужные слушатели событий).

В `useEffect` можно вернуть функцию очистки – она выполнится перед удалением компонента.

**Пример 3**. _Вывод сообщения при удалении компонента_

```jsx
import React, { useEffect, useState } from 'react';

function ToggleMessage() {
  const [visible, setVisible] = useState(true);

  return (
    <div>
      {visible && <Message />}
      <button onClick={() => setVisible(!visible)}>
        {visible ? 'Скрыть' : 'Показать'} сообщение
      </button>
    </div>
  );
}

function Message() {
  useEffect(() => {
    return () => {
      console.log('Компонент удален!');
    };
  }, []);

  return <h1>Привет! Нажми кнопку, чтобы спрятать меня.</h1>;
}

export default ToggleMessage;
```

**В примере выше происходит следующее**:

1. `Message` появляется на экране → ничего не происходит.
2. Пользователь нажимает кнопку **"Скрыть"** → компонент удаляется.
3. React вызывает функцию очистки, которая пишет **"Компонент удален!"**.

> [!TIP]
> Функция очистки в `useEffect` помогает избежать утечек памяти, особенно при подписке на события или работе с таймерами.

### Зависимости в `useEffect`

**Зависимости** — это массив значений, от которых зависит выполнение `useEffect`. Если хотя бы одно из этих значений изменится, React вызовет `useEffect` заново.

Можно указать несколько зависимостей, чтобы `useEffect` реагировал на изменения нескольких переменных.

**Пример 4**. _Использование зависимостей в `useEffect`_

```jsx
import React, { useState, useEffect } from 'react';

function LoginForm() {
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const [isDisabled, setIsDisabled] = useState(true);

  useEffect(() => {
    if (username.length >= 3 && password.length >= 6) {
      setIsDisabled(false);
    } else {
      setIsDisabled(true);
    }
  }, [username, password]); // useEffect следит за изменениями username и password

  return (
    <div>
      <h2>Вход</h2>
      <input
        type="text"
        placeholder="Логин"
        value={username}
        onChange={(e) => setUsername(e.target.value)}
      />
      <input
        type="password"
        placeholder="Пароль"
        value={password}
        onChange={(e) => setPassword(e.target.value)}
      />
      <button disabled={isDisabled}>Войти</button>
    </div>
  );
}

export default LoginForm;
```

**В примере выше происходит следующее**:

1. `useEffect` отслеживает изменения `username` и `password`.
2. Если длина логина больше или равна 3 символам, а длина пароля больше или равна 6, кнопка **"Войти"** становится активной.
3. В противном случае кнопка остается заблокированной.

Также можно использовать несколько `useEffect` в одном компоненте — каждый из них будет независимо отслеживать свои зависимости.

### Пример: использование `useEffect` для реализации слайдера постов

В прошлой теме мы создали слайдер постов, который позволяет переключаться между постами. Теперь добавим автоматическое переключение слайдов каждые **5 секунд**.

```jsx
// Slider.jsx
import React from 'react';

import { posts } from './posts';

function Slider() {
  const [index, setCurrentIndex] = React.useState(0);
  const [isDescription, setIsDescription] = React.useState(false);

  // Добавляем useEffect для автоматического переключения слайдов
  React.useEffect(() => {
    const interval = setInterval(() => {
      // Переключение слайдов каждые 5 секунд
      //
      // Если index равен последнему индексу, то переключаем на первый
      // Иначе увеличиваем на 1
      setCurrentIndex((prevIndex) => (prevIndex + 1) % posts.length);
    }, 5000);

    // Очистка таймера при размонтировании компонента
    // Необходимо для избежания утечек памяти
    // и повторного выполнения таймера после удаления компонента
    return () => {
      clearInterval(interval);
    };
  }, []);

  function showDescription() {
    setIsDescription(!isDescription);
  }

  function nextPost() {
    if (index < posts.length - 1) {
      setCurrentIndex(index + 1);
    }
  }

  function previosPost() {
    if (index > 0) {
      setCurrentIndex(index - 1);
    }
  }

  let currentPost = posts[index];

  return (
    <div>
      <h2>{currentPost.title}</h2>
      <div>
        <p>
          ({index + 1} of {posts.length})
        </p>
      </div>
      {/* Если isDescription равно true, то показываем кнопку */}
      <button onClick={showDescription}>{isDescription ? 'Hide' : 'Show'} description</button>
      <p>{isDescription && currentPost.content}</p>
      <button onClick={nextPost}>Next post</button>
      <button onClick={previosPost}>Previous post</button>
    </div>
  );
}

export default Slider;
```

## Recap: Жизненный цикл компонента и `useEffect`

1. **Жизненный цикл компонента** включает три стадии:

   - **Монтирование (mounting)** – компонент создаётся и добавляется в DOM.
   - **Обновление (updating)** – компонент обновляется при изменении состояния (`state`) или пропсов (`props`).
   - **Размонтирование (unmounting)** – компонент удаляется из DOM.

2. **Хук `useEffect`** позволяет управлять побочными эффектами в функциональных компонентах, такими как загрузка данных, подписка на события и очистка ресурсов.

3. **Монтирование компонента**:

   - Используем `useEffect(() => { ... }, [])`, чтобы выполнить код один раз после появления компонента в DOM.

4. **Обновление компонента**:

   - Передаём массив зависимостей `useEffect(() => { ... }, [dependency])`, чтобы эффект срабатывал при изменении определённого значения.

5. **Размонтирование компонента**:

   - Функция очистки `return () => { ... }` в `useEffect` вызывается перед удалением компонента и используется для освобождения ресурсов (например, удаления таймеров или подписок).

6. **Примеры применения `useEffect`**:

   - Вывод сообщения в консоль при монтировании.
   - Обновление компонента при изменении состояния.
   - Очистка ресурсов при удалении компонента.
   - Автоматическое переключение слайдов в слайдере.
   - др.

7. **Зависимости в `useEffect`**:

   - Массив зависимостей указывает, когда должен срабатывать `useEffect`.
   - Если массив пуст (`[]`), эффект выполняется один раз.
   - Если указаны зависимости (`[state, props]`), эффект выполняется при их изменении.

8. **Функция очистки в `useEffect`**:
   - Используется для предотвращения утечек памяти, например, при удалении обработчиков событий или остановке таймеров.

[^1]: _Embracing the React Functional Component Lifecycle: A Simple Guide with Hooks_. hashnode.dev [online resource]. Available at: https://morshedulmunna.hashnode.dev/embracing-the-react-functional-component-lifecycle-a-simple-guide-with-hooks
