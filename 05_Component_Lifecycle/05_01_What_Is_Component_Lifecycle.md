# Что такое жизненный цикл компонента?

## Аналогия из реальной жизни

Представьте себе человека. Вы наверняка знакомы с понятием "жизненный цикл". Проще говоря, это этапы, через которые проходит человек от рождения до смерти: рождение, взросление, обучение, работа, выход на пенсию и, в конечном итоге, смерть. Однако жизненный цикл присущ не только людям, но и многим другим объектам, например, продуктам питания или автомобилям. В глобальном смысле, жизненный цикл человека можно разделить на три основные стадии: _рождение, развитие (включающее обучение и трудовую деятельность) и завершение_.

## Жизненный цикл компонента

Как и у человека, у компонента также есть жизненный цикл.

**Жизненный цикл компонента** — это последовательность этапов, которые он проходит от создания до удаления. В React он включает три основных стадии:

- **Создание (монтирование) (mounting)**
- **Обновление (updating)**
- **Удаление (размонтирование) (unmounting)**

Компонент проходит эти этапы в зависимости от выполняемых над ним операций.

Для отслеживания и управления жизненным циклом компонента в React (_> 16.8_) используется хук `useEffect`. Этот хук позволяет выполнять побочные эффекты в функциональных компонентах.

> [!TIP] > **Побочные эффекты** — это любые действия, которые необходимо выполнить в процессе работы приложения, например, загрузка данных, обновление DOM или подписка на события.

Синтаксис хука `useEffect`:

```jsx
import { useEffect } from "react";

useEffect(
  () => {
    // Логика побочного эффекта

    return () => {
      // Очистка побочного эффекта
    };
  },
  [
    /* Зависимости */
  ]
);
```

На первый взгляд, `useEffect` может показаться сложным, но на самом деле он очень прост в использовании. Все, что вам нужно сделать, это передать функцию в качестве аргумента, и React выполнит ее в нужный момент.

### Создание компонента (монтирование)

**Когда происходит монтирование?**. Когда компонент добавляется в DOM. Простыми словами, когда все HTML-элементы компонента отображаются на экране.

**Создание компонента** — это начальный этап его жизненного цикла, на котором он добавляется в DOM. В этот момент можно выполнить определенные действия, _например_, настроить таймер, подписаться на события или вывести сообщение в консоль. Чтобы React выполнил код сразу после появления компонента, используют хук useEffect с пустым массивом зависимостей `[]`. Это гарантирует, что эффект сработает только один раз.

**Пример 1**. _Вывод сообщения при монтировании компонента_

```jsx
import { useEffect } from "react";

function App() {
  useEffect(() => {
    // Этот код выполнится один раз после появления компонента
    console.log("Компонент появился на экране");
  }, []);

  return <h1>Привет, мир!</h1>;
}
```

**Что происходит в этом коде**:

- Компонент рендерится и отображает заголовок "Привет, мир!".
- После монтирования выполняется useEffect, который выводит в консоль **"Компонент появился на экране!"**.

> [!TIP]
> В `useEffect` можно передавать как стрелочную, так и именованную функцию.

### Обновление компонента

**Когда происходит обновление?**. Когда компонент обновляется в результате изменения: состояния (_state_), пропсов (_props_) или контекста.

Чтобы реагировать на такие изменения, в `useEffect` передается массив зависимостей. Если одно из значений в этом массиве изменится, React вызовет `useEffect` заново.

**Пример 2**. _Обновление компонента при изменении состояния_

```jsx
import React, { useState, useEffect } from "react";

function Counter() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    console.log(`Счетчик обновился: ${count}`);
  }, [count]); // useEffect выполняется при каждом изменении count

  return (
    <div>
      <p>Счетчик: {count}</p>
      <button onClick={() => setCount(count + 1)}>Добавить 1</button>
    </div>
  );
}

export default Counter;
```

**Что происходит в этом коде**:

1. Когда пользователь нажимает кнопку, `count` увеличивается.
2. React перерисовывает компонент.
3. Так как `count` изменился, `useEffect` снова выполняется и пишет **"Счетчик обновился: X"** в консоль.

Даже если `useEffect` настроен на выполнение только при изменении `count`, он также срабатывает при первом рендере.

Если пользователь нажмет кнопку четыре раза, в консоли появится:

```cpp
Счетчик обновился: 0 // Первый рендер
Счетчик обновился: 1 // Первое обновление
Счетчик обновился: 2 // Второе обновление
Счетчик обновился: 3 // Третье обновление
Счетчик обновился: 4 // Четвертое обновление
```

### Удаление компонента (размонтирование)

**Когда происходит размонтирование?**. Когда компонент удаляется из DOM, когда он больше не нужен и перестает отображаться на экране.

Иногда, при _'скрытии'_ компонента полезно "убрать за собой" (_например_, остановить таймер или удалить ненужные слушатели событий).

В `useEffect` можно вернуть функцию очистки – она выполнится перед удалением компонента.

**Пример 3**. _Вывод сообщения при удалении компонента_

```jsx
import React, { useEffect, useState } from "react";

function ToggleMessage() {
  const [visible, setVisible] = useState(true);

  return (
    <div>
      {visible && <Message />}
      <button onClick={() => setVisible(!visible)}>
        {visible ? "Скрыть" : "Показать"} сообщение
      </button>
    </div>
  );
}

function Message() {
  useEffect(() => {
    return () => {
      console.log("Компонент удален!");
    };
  }, []);

  return <h1>Привет! Нажми кнопку, чтобы спрятать меня.</h1>;
}

export default ToggleMessage;
```

1. `Message` появляется на экране → ничего не происходит.
2. Пользователь нажимает кнопку **"Скрыть"** → компонент удаляется.
3. React вызывает функцию очистки, которая пишет **"Компонент удален!"**.

> [!TIP]
> Функция очистки в `useEffect` помогает избежать утечек памяти, особенно при подписке на события или работе с таймерами.

[^1]: _Embracing the React Functional Component Lifecycle: A Simple Guide with Hooks_. hashnode.dev [online resource]. Available at: https://morshedulmunna.hashnode.dev/embracing-the-react-functional-component-lifecycle-a-simple-guide-with-hooks
