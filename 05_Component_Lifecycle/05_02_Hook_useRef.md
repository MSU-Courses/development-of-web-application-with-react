# Хук useRef

Следующим на очереди важным хуком является `useRef`.

Иногда в React-компоненте нужно хранить значение, которое должно сохраняться между рендерами, но при этом не вызывать повторный рендеринг при изменении. В таких случаях используется `useRef`. Проще говоря, с помощью `useRef` можно сохранить какую-то информацию, которая не влияет напрямую на отображение интерфейса, и менять её по мере необходимости, не заставляя компонент заново рисоваться каждый раз [^1].

Этот хук создаёт объект с единственным свойством `current`, в котором можно хранить любое значение. В отличие от состояния (`useState`), обновление current не приводит к повторному рендеру компонента.

## Синтаксис

```jsx
const ref = useRef(initialValue);
```

- `initialValue` — начальное значение, которое будет храниться в `ref.current`.
- `ref.current` — свойство, в котором хранится текущее значение.

## Пример: Таймер с использованием useRef

Рассмотрим понятный пример, демонстрирующий преимущество `useRef`. Мы создадим простой таймер-компонент, который подсчитывает секунды и позволяет его запускать и останавливать.

В этом примере:

- Мы будем отображать число секунд на экране (это состояние меняется каждую секунду, и должно обновлять UI — значит, для секунд используем `useState`).
- Мы будем сохранять ID интервала (таймера), чтобы уметь его останавливать. Этот ID не отображается в UI и его изменение не должно влиять на интерфейс — идеальный случай для `useRef`.

```jsx
import { useState, useRef, useEffect } from 'react';

function Timer() {
  const [seconds, setSeconds] = useState(0); // состояние для секунд (отображается в UI)
  const timerRef = useRef(null); // реф для хранения ID таймера (не в UI)

  const startTimer = () => {
    if (timerRef.current !== null) {
      // Таймер уже запущен, не запускаем новый
      return;
    }
    timerRef.current = setInterval(() => {
      // каждую секунду увеличиваем счётчик
      // это изменение состояния, которое приведёт к перерисовке компонента
      setSeconds((prev) => prev + 1);
    }, 1000);
  };

  const stopTimer = () => {
    if (timerRef.current !== null) {
      clearInterval(timerRef.current); // останавливаем таймер по ID
      timerRef.current = null; // сбрасываем реф (таймер остановлен)
    }
  };

  useEffect(() => {
    // Очистка таймера при размонтировании компонента, на случай если он еще работает
    return () => {
      clearInterval(timerRef.current);
    };
  }, []);

  return (
    <div>
      <h3>Секунды: {seconds}</h3>
      <button onClick={startTimer}>Start</button>
      <button onClick={stopTimer}>Stop</button>
    </div>
  );
}
```

В данном примере:

1. Мы используем `useState` для переменной `seconds` – это обычный счётчик, который отображается на экране. Каждое обновление `seconds` через `setSeconds` приводит к перерисовке компонента, и мы видим обновлённое число секунд в `<h3>`.
2. Мы используем `useRef` (инициализируя как `null`) для хранения идентификатора таймера `timerRef`. По умолчанию таймер не запущен, поэтому изначально `timerRef.current` равен `null`.
3. Функция `startTimer` запускает новый интервал с помощью `setInterval`. Внутри интервала каждую секунду вызывается `setSeconds(prev => prev + 1)`, что увеличивает состояние `seconds` на `1` и тем самым обновляет UI. Полученный от `setInterval` идентификатор интервала мы сохраняем в `timerRef.current`.
   1. Перед запуском мы проверяем `if (timerRef.current !== null)`, чтобы не создавать новый таймер, если старый ещё работает. Это защита от многократного нажатия на `"Start"`.
4. Функция `stopTimer` останавливает интервал: она берёт текущий ID таймера из `timerRef.current` и передаёт его в `clearInterval`, после чего устанавливает `timerRef.current = null` (таймер остановлен, реф больше не хранит ID действующего интервала).
5. В `useEffect` мы возвращаем функцию очистки, которая сработает при размонтировании компонента. Это нужно на случай, если пользователь не нажал **"Stop"**, а компонент убран со страницы — тогда мы всё равно очистим интервал, чтобы он не продолжал работу в фоне.

**Почему мы выбрали `useRef` для хранения ID таймера вместо `useState`?**

Рассмотрим альтернативный вариант, где мы храним ID таймера в состоянии.

```jsx
import { useState, useEffect } from 'react';

function Timer() {
  const [seconds, setSeconds] = useState(0); // состояние для секунд (отображается в UI)
  const [timerId, setTimerId] = useState(null); // состояние для ID таймера

  const startTimer = () => {
    if (timerId !== null) {
      // Таймер уже запущен, не запускаем новый
      return;
    }
    const id = setInterval(() => {
      // каждую секунду увеличиваем счётчик
      // это изменение состояния, которое приведёт к перерисовке компонента
      setSeconds((prev) => prev + 1);
    }, 1000);
    setTimerId(id);
  };

  const stopTimer = () => {
    if (timerId !== null) {
      clearInterval(timerId); // останавливаем таймер по ID
      setTimerId(null); // сбрасываем состояние (таймер остановлен)
    }
  };

  useEffect(() => {
    // Очистка таймера при размонтировании компонента, на случай если он еще работает
    return () => {
      clearInterval(timerId);
    };
  }, [timerId]);

  return (
    <div>
      <h3>Секунды: {seconds}</h3>
      <button onClick={startTimer}>Start</button>
      <button onClick={stopTimer}>Stop</button>
    </div>
  );
}
```

При каждом запуске или остановке таймера нам приходится вызывать `setTimerId`, что приводит к перерисовке компонента. С `useRef` мы избегаем этой проблемы: мы сохраняем ID таймера, не затрагивая цикл рендера React. Функции `startTimer` и `stopTimer` просто читают или записывают значение `timerRef.current` напрямую, без вызова функции рендера компонента. В результате кнопки **"Start"/"Stop"** не вызывают дополнительных перерисовок, UI меняется только тогда, когда меняется состояние seconds каждую секунду.

**Рассмотрим эту разницу в виде таблицы**:

| Хранение таймера с помощью `useState`                     | Хранение таймера с помощью `useRef`                     |
| --------------------------------------------------------- | ------------------------------------------------------- |
| ![Component with useState](https://imgur.com/hExhfHX.png) | ![Component with useRef](https://imgur.com/USmcPnN.png) |

В первом случае каждое изменение состояния `timerId` вызывает перерисовку компонента, во втором — нет.

##

Попробуем наоборот использовать useRef для изменения состояния компонента. Попробуем реализовать `Counter`, который увеличивает значение на 1 при каждом клике на кнопку.

```jsx
import { useState, useRef } from 'react';

function Counter() {
  const countRef = useRef(count);

  const handleClick = () => {
    countRef.current += 1;
  };

  return (
    <div>
      <h3>Счётчик: {count}</h3>
      <button onClick={handleClick}>Увеличить</button>
    </div>
  );
}

export default Counter;
```

Если мы будем нажимать на кнопку, то значение `count` не изменится. Почему так происходит?

<details>
<summary>Ответ</summary>

Как было сказано ранее, изменение `countRef.current` не вызывает перерисовку компонента. React не знает, что значение изменилось, и не вызывает перерисовку компонента, поэтому на экране не отображается новое значение. Для того чтобы изменения отобразились, нужно использовать `useState`.

</details>

## Использование `useRef` для работы с DOM

Чаще же `useRef` используется для работы с DOM-элементами [^2].

Как вы поняли с прошлых глав, React сам обновляет DOM, когда меняются состояния или пропсы компонента. Но иногда нам нужно **получить доступ к DOM-элементу напрямую**. _Например_, установить фокус на поле ввода, изменить размер элемента или добавить анимацию.

**Рассмотрим проблему**: нам нужно изменить какое-то свойство DOM-элемента.

Можно обойтись и без `useRef`, используя, например, глобальный доступ к DOM через `document.getElementById`. Вот пример, который устанавливает фокус на поле ввода:

```jsx
import React, { useEffect } from 'react';

function Input() {
  useEffect(() => {
    const input = document.getElementById('myInput');
    if (input) {
      input.focus();
    }
  }, []);

  const handleClick = () => {
    const input = document.getElementById('myInput');
    if (input) {
      input.focus();
    }
  };

  return (
    <div>
      <input id="myInput" type="text" placeholder="Введите текст..." />
      <button onClick={handleClick}>Фокус на поле</button>
    </div>
  );
}
```

**Почему такой подход плохой?**

- Использование `document.getElementById` заставляет вас искать элемент во всём DOM, а не внутри конкретного компонента. Это означает, что компонент становится зависимым от глобальной структуры страницы, что ухудшает модульность и повторное использование.
- Если на странице окажется несколько компонентов с одинаковыми ID, поиск через `document.getElementById` вернёт непредсказуемый результат. Это может привести к ошибкам, особенно в больших приложениях.
- React создан для работы с виртуальным DOM и декларативным описанием UI. Прямое обращение к реальному DOM через глобальные методы противоречит этой парадигме и может привести к проблемам синхронизации между виртуальным и реальным DOM.
- Когда вы используете `useRef`, React сам следит за привязанными элементами и гарантирует, что ссылка будет актуальной даже после ререндера.

Именно поэтому `useRef` — это предпочтительный способ работы с DOM-элементами в React.

### Получение ссылки на DOM-элемент

​Чтобы получить ссылку на DOM-элемент в React, используется хук `useRef`. Он позволяет создавать изменяемый объект, сохраняющийся между рендерами компонента, и предоставляет доступ к свойству `current`, где хранится ссылка на DOM-элемент. [^3] ​

**Пример 1.** _Использования useRef для получения ссылки на DOM-элемент_

```jsx
function Component() {
  const elementRef = useRef(null);

  console.log(elementRef.current); // null

  useEffect(() => {
    // В elementRef.current хранится ссылка на DOM-элемент
    console.log(elementRef.current);
  }, []);

  return <div ref={elementRef}>Ссылка на этот элемент</div>;
}
```

Как Вы думаете, Почему в первом `console.log` выводится `null`, а во втором — ссылка на DOM-элемент?

<details>
<summary>Ответ</summary>

1. При инициализации `useRef(null)` создаётся объект со свойством `current`, равным `null`.
2. В процессе рендеринга JSX-элемент `<div>` получает атрибут `ref={elementRef}`, но на этом этапе `elementRef.current` всё ещё `null`.
3. После монтирования компонента, в хуке `useEffect`, React присваивает `elementRef.current` ссылку на соответствующий DOM-элемент `<div>`. ​
</details>

#### Пример: Фокус на поле ввода

```jsx
import { useRef } from 'react';

function Input() {
  const inputRef = useRef(null);

  const handleClick = () => {
    inputRef.current.focus();
  };

  return (
    <div>
      <input ref={inputRef} type="text" placeholder="Введите текст..." />
      <button onClick={handleClick}>Фокус на поле</button>
    </div>
  );
}
```

В данном примере:

- Создаётся реф `inputRef` с помощью `useRef(null)`.
- Реф передаётся в атрибут `ref` элемента `<input>`, связывая `inputRef.current` с этим DOM-элементом (`<input ref={inputRef}>`).
- В обработчике `handleClick` вызывается метод `focus()` на `inputRef.current`, устанавливая фокус на поле ввода при клике на кнопку.

### Пример: Динамическое изменение стиля компонента

Другой случай – изменить стиль DOM-элемента напрямую, например, поменять цвет кнопки при клике. В React обычно стили изменяются через состояние (меняя класс или инлайн-стиль с помощью состояния), но `useRef` позволяет сделать это императивно, не перерисовывая весь компонент. Рассмотрим пример, где при клике на кнопку она сама меняет свой цвет:

```jsx
import React, { useRef } from 'react';

function ColorToggle() {
  const buttonRef = useRef(null);

  const changeColor = () => {
    if (buttonRef.current) {
      buttonRef.current.style.backgroundColor = 'green';
      buttonRef.current.style.color = 'white';
    }
  };

  return (
    <button ref={buttonRef} onClick={changeColor}>
      Нажми меня
    </button>
  );
}

export default ColorToggle;
```

Здесь `buttonRef` ссылается на DOM-узел `<button>`.

1. Создаётся реф `buttonRef` с помощью `useRef(null)`.
2. Реф передаётся в атрибут `ref` элемента `<button>`, связывая `buttonRef.current` с этим DOM-элементом.​
3. В функции `changeColor` проверяется наличие `buttonRef.current`, после чего напрямую изменяются стили кнопки, устанавливая зелёный фон и белый цвет текста. Это одно и то же, что делать через `element.style` в чистом JavaScript.

> [!IMPORTANT]
> Изменяя DOM напрямую, мы берём ответственность за то, чтобы UI оставался **консистентным**. В нашем примере всё просто – мы всего лишь поменяли цвет кнопки. Если бы стили зависели от состояния приложения, лучше было бы использовать useState и привязать стили к нему. Но для локальных эффектов, как здесь, useRef вполне оправдан.

Теперь для получения элементов, мы не используем `document.getElementById` и не зависим от глобального контекста. Вместо этого мы получаем ссылку на DOM-элемент через `ref`, который React обновляет автоматически.

## Когда использовать `useRef`

Нет универсального правила для использования `useRef`, но есть несколько рекомендаций:

1. **Доступ к DOM-элементам**. `useRef` позволяет получить ссылку на DOM-элементы без необходимости использовать глобальные методы, такие как `document.getElementById` или `querySelector`. Это особенно полезно для управления фокусом, анимациями и изменением стилей.

2. **Хранение данных между рендерами**. Если необходимо сохранить значение, которое не должно приводить к повторному рендеру компонента (_например_, идентификатор таймера или предыдущее значение переменной), лучше использовать `useRef`, а не `useState`.

В остальных случаях, когда изменение значения должно привести к перерисовке компонента и отобразить изменения в UI, лучше использовать `useState`.

## Recap: Хук `useRef`

1. **Что такое `useRef`?**

   - Хук `useRef` позволяет хранить изменяемое значение, которое сохраняется между рендерами, но **не вызывает повторный рендер** при изменении.

2. **Синтаксис:**

   ```jsx
   const ref = useRef(initialValue);
   ```

   - `ref.current` содержит текущее значение, которое можно изменять без повторного рендера.

3. **Применение `useRef`:**

   - **Работа с DOM**: получение ссылки на DOM-элемент (например, установка фокуса на поле ввода).
   - **Хранение данных между рендерами**: можно сохранять, например, идентификатор таймера, предыдущее значение переменной и т. д.

4. **Работа с DOM через `useRef`:**

   - Можно передать `useRef` в атрибут `ref` элемента и напрямую изменять его свойства.

5. **Когда использовать `useRef`?**

   - Когда **не нужно** обновлять компонент при изменении значения (`useState` вызывает ререндер, `useRef` – нет).
   - Когда **нужно** получить ссылку на DOM-элемент и работать с ним напрямую.

6. **Когда НЕ использовать `useRef`?**
   - Если значение должно обновлять интерфейс — в этом случае лучше использовать `useState`.

> [!NOTE]
>  `useRef` — это мощный инструмент для работы с DOM и хранения данных между рендерами без лишних обновлений интерфейса.

[^1]: _Referencing Values with Refs_. react.dev [online resource]. Available at: https://react.dev/learn/referencing-values-with-refs
[^2]: _Manipulating the DOM with Refs_. react.dev [online resource]. Available at: https://react.dev/learn/manipulating-the-dom-with-refs
[^3]: _Как работает useRef в React?_. Hack Frontend [online resource]. Available at: https://www.hackfrontend.com/docs/react/react-hooks-4
