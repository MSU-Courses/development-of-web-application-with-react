# Введение в REST

Термины REST API и RESTful веб-сервис относятся к архитектурному стилю REST (Representational State Transfer), что переводится как «передача представления состояния» или, в более свободной форме, — «передача состояния представления». Этот стиль был предложен Роем Филдингом (Roy Fielding) – одним из создателей HTTP – в 2000 году в его докторской диссертации​ [^1]. Филдинг исследовал, как должна выглядеть архитектура распределенной системы (в частности, системы World Wide Web), чтобы она была масштабируемой, гибкой и простотой в взаимодействии. В своей работе он не «изобрел интернет» заново, а формализовал принципы, на которых уже базировалась Всемирная паутина, дав этому подходу название REST.

REST (Representational State Transfer) — это не протокол и не стандарт, а архитектурный стиль взаимодействия между приложениями. Он описывает набор принципов и ограничений, которым должна соответствовать система. Если система полностью удовлетворяет этим требованиям, её можно назвать RESTful-системой. В контексте веб-сервисов, реализованных по этим принципам, часто используется термин RESTful API.

**Основная идея REST** – заставить взаимодействующие компоненты системы (клиенты и серверы) обмениваться информацией так, чтобы их взаимодействие было как можно более простым и унифицированным, без лишних зависимостей и состояний. _Проще говоря_, REST предлагает: давайте использовать принципы, на которых работает веб (HTTP, URI, простые запросы и ответы, отсутствие сохранения сессии на сервере и т.п.), для построения любых веб-сервисов. Если все сделано правильно, получаем систему, которая легко масштабируется.

**Ключевая идея REST** — построить взаимодействие между клиентом и сервером максимально простым, стандартизированным и независимым. REST предлагает использовать те принципы, на которых уже основана работа самого веба: протокол HTTP, уникальные идентификаторы ресурсов (URI), простые запросы и ответы, отсутствие сохранения состояния на сервере. _Проще говоря_, REST говорит: давайте использовать проверенные временем механизмы интернета для создания любых веб-сервисов. Такой подход делает систему гибкой, масштабируемой и легко расширяемой.

Филдинг, автор концепции REST, выделил **шесть основных ограничений**, которые формируют архитектурный стиль REST. Из них **пять являются обязательными**, а **шестое — необязательное, но рекомендованное**. Перед тем как перейти к их подробному рассмотрению, стоит прояснить важные термины.

Термины REST и RESTful API часто употребляются как синонимы, однако между ними есть важное различие:

- **REST** — это название архитектурного стиля.
- **RESTful API** — это конкретная реализация API, соответствующая принципам REST.

Иными словами, RESTful означает «построенный в соответствии с REST». Поэтому можно услышать такие формулировки, как:

> «У нас API не совсем RESTful, потому что не поддерживает все методы»
> или
> «Наш API хранит сессию на сервере — это нарушает принцип Stateless».

С технической точки зрения, если нарушено хотя бы одно из ограничений REST, то это уже не RESTful система. Однако в практике разработки термин «REST API» часто используется менее строго — так называют любой веб-сервис, который хотя бы отчасти следует духу REST. В этой главе мы ориентируемся на максимально правильный RESTful-подход, но важно понимать, что в реальных проектах можно встретить множество **«почти RESTful» API**.

### Главная идея REST

Основная идея REST заключается в том, что одно приложение (_например_, веб-приложение интернет-магазина) отправляет HTTP-запрос к другому приложению — веб-сервису, а тот в ответ возвращает данные в структурированном формате, чаще всего JSON. _Проще говоря_: REST — это способ, при котором клиент (_например_, сайт или мобильное приложение) запрашивает нужную информацию у сервера с помощью HTTP, а сервер отвечает данными, которые можно обработать и отобразить пользователю.

**Пример**. _Взаимодействие клиента и сервера в REST API_

Веб-приложение "Интернет-магазин" отправляет HTTP-запрос к веб-сервису "Управление товарами", чтобы получить информацию о товаре с идентификатором 42. Запрос может выглядеть так:

```http
GET /products/42 HTTP/1.1
Host: api.shop.com
```

В ответ веб-сервис возвращает данные о товаре в формате JSON:

```json
{
  "id": 42,
  "name": "Кофеварка",
  "price": 249.99,
  "inStock": true
}
```

Такой подход упрощает обмен данными между различными приложениями и системами, что делает REST API одним из самых популярных решений для разработки веб-сервисов. Вместо работы с файлами теперь используются HTTP-запросы и ответы, что значительно ускоряет и упрощает взаимодействие.

Однако важно понимать, что простой обмен по принципу «запрос–ответ» ещё не делает API REST. REST — это не просто способ передачи данных, а архитектурный стиль, который накладывает определённые ограничения и принципы на то, как клиент и сервер взаимодействуют друг с другом. Далее мы рассмотрим эти ограничения подробнее.

## Архитектурные принципы REST

Как уже упоминалось ранее, Рой Филдинг в своей работе сформулировал шесть архитектурных ограничений (constraints), которым должна соответствовать система, чтобы её можно было считать RESTful. Соблюдение этих ограничений при проектировании даёт системе такие важные свойства, как масштабируемость, надёжность, устойчивость к изменениям и простота сопровождения.

Для более наглядного и интуитивно понятного объяснения каждого ограничения, после его описания мы будем рассматривать его применение на конкретном примере из предыдущего раздела:

- Веб-приложение «Интернет-магазин», разработанное на JavaScript.
- Веб-сервис «Управление товарами», реализованный на PHP.

### 1. Клиент-серверная архитектура (Client-Server)

Первый ключевой принцип REST — клиент-серверная модель. Он предполагает чёткое разделение обязанностей между клиентом и сервером:

- Клиент инициирует запросы и отвечает за отображение или обработку полученных данных.
- Сервер принимает эти запросы, обрабатывает их и возвращает ответ с нужной информацией.

> [!TIP]
> Клиент — это не только браузер. Это может быть любое приложение (веб, мобильное, десктопное), которое отправляет HTTP-запросы. Сервер — это любое приложение, способное обрабатывать запросы и возвращать ответы, чаще всего в формате JSON или XML.

Такое разделение даёт ряд преимуществ:

- **Независимость разработки**. Клиент и сервер могут развиваться отдельно, соблюдая договорённости API.
- **Портативность клиента**. Один и тот же сервер может обслуживать разные приложения — веб-сайт, мобильное приложение, партнёрский сервис.
- **Унифицированность взаимодействия**. Клиенту не нужно знать внутреннее устройство сервера, и наоборот.

#### Пример на практике

В рассмотренном примере:

- **Клиент** — веб-приложение "Интернет-магазин", написанное на JavaScript. Оно отправляет HTTP-запросы к серверу, чтобы получить информацию о товарах.
- **Сервер** — веб-сервис "Управление товарами", написанный на PHP. Он обрабатывает запросы от клиента и возвращает данные о товарах.

Клиенту всё равно, на чём написан сервер (PHP, Python, Go) — важно лишь, чтобы он корректно отвечал по API. А сервер не интересуется, откуда пришёл запрос — будь то браузер, мобильное приложение или сторонняя система.

**Пример обмена запросом**:

1. Клиент отправляет запрос к серверу по сети, _например_: `GET https://api.example.com/products` (получить список продуктов).
2. Сервер принимает запрос, обрабатывает его — _например_, извлекает список товаров из базы данных.
3. Затем сервер формирует ответ в формате JSON и отправляет его клиенту с HTTP-статусом 200 OK:
   ```json
   [
     { "id": 1, "name": "Кофеварка", "price": 249.99 },
     { "id": 2, "name": "Чайник", "price": 99.99 }
   ]
   ```
4. Клиент получает ответ, обрабатывает его и обновляет интерфейс для пользователя (_например_, отображает список товаров на странице).

Такой подход позволяет подключать к одному серверу сразу несколько клиентов: веб-сайт, мобильное приложение, приложения партнёров и т. д. Сервер при этом остаётся универсальным и независимым от конкретных интерфейсов.

### 2. Отсутствие состояния (Stateless)

Второй ключевой принцип REST — отсутствие состояния на стороне сервера (Stateless). Это означает, что сервер не сохраняет никакой информации о предыдущих взаимодействиях с клиентом. Каждый HTTP-запрос должен содержать всю необходимую информацию для его обработки — сервер не опирается на историю предыдущих запросов. _Проще говоря_, каждый запрос должен рассматриваться как полностью самостоятельный: сервер «не помнит», что происходило ранее, и не поддерживает сессий или иных форм состояния между запросами.

В традиционных веб-приложениях используется механизм сессий: пользователь авторизуется, и сервер запоминает его (например, по идентификатору сессии). При последующих запросах сервер «узнаёт» пользователя по этой сессии. Но с точки зрения чистого REST — такой подход нарушает принцип Stateless. В REST, если требуется идентификация пользователя, соответствующие данные необходимо передавать в каждом запросе — например, \**логин и парол*ь*, а чаще всего — *токен авторизации\*. Таким образом, каждый запрос обрабатывается сервером изолированно, без зависимости от предыдущих.

Преимущества данного подхода:

- **Масштабируемость и надёжность**. Если на сервере не хранится состояние, то легко балансировать нагрузку: любой экземпляр сервера может обслужить любой запрос, не важно, кто раньше что запрашивал. Клиента можно при каждом запросе направить на случайный сервер (в кластер), и ничего не сломается.
- **Упрощение сервера**. Сервер не тратит память на хранение состояний множества клиентов, не надо думать о синхронизации сессий между серверами.
- **Независимость**. Протокол взаимодействия становится проще – каждый запрос самодостаточен. Это как отправлять письма по почте: каждое письмо содержит адрес отправителя и получателя, содержимое – и доставляется само по себе.

#### Пример на практике

В рассмотреном примере:

Допустим, в веб-сервисе «Управление товарами» существует эндпоинт `/api/profile` для получения данных о пользователе.

В классическом подходе с использованием сессий процесс выглядел бы так:

1. Пользователь авторизуется через `POST /login`.
2. Сервер сохраняет данные о пользователе в `$_SESSION`.
3. При последующем запросе, например `GET /api/profile`, сервер извлекает данные из `$_SESSION`, чтобы определить, кто делает запрос.

При последующем запросе, например `GET /api/profile`, сервер извлекает данные из `$_SESSION`, чтобы определить, кто делает запрос.

1. Пользователь отправляет запрос на авторизацию, сервер возвращает токен — уникальный идентификатор сессии, например: `"token": "j8sdfu89sdfh8sdfj"`.
2. При каждом последующем запросе клиент передаёт токен серверу. Чаще всего токен передается в заголовке `Authorization`. Например: `Authorization: Bearer j8sdfu89sdfh8sdfj`.
3. Сервер проверяет токен, сопоставляет его с пользователем (например, сервер хранит в базе данных информацию `пользователь - токен`), и на этой основе авторизует запрос.

Таким образом, каждый запрос полностью самодостаточен:

- Если токен не передан — сервер не может идентифицировать пользователя и отклоняет запрос.
- Если токен присутствует и действителен — этого достаточно для обработки запроса, **независимо от того, были ли запросы до этого**.

Таким образом, каждый запрос самодостаточен: если токен не передан, сервер не знает, кто вы – и отклонит запрос, а если передан – этого достаточно для авторизации, независимо от предыдущих вызовов.

Stateless не означает, что сервер вообще не хранит данные. Он может использовать базы данных, кэш и прочие хранилища. Речь идёт именно об отсутствии хранимого контекста взаимодействия между запросами. Каждый HTTP-запрос — как отдельное обращение, без «диалога» с сервером.

Важно отметить, что сам протокол HTTP изначально не сохраняет состояние: каждый запрос — независим. Однако многие веб-приложения добавляли поверх него механизм сессий (через cookie и серверную память). REST призывает отказаться от этого подхода при разработке веб-сервисов, чтобы обеспечить гибкость, надёжность и масштабируемость системы.

### 3. Кэшируемость (Cacheable)

Третий важный принцип REST — кэшируемость ответов. Он предполагает, что сервер должен явно указывать, можно ли кэшировать конкретный ответ, чтобы клиент или промежуточные узлы (например, прокси-серверы) могли использовать локальные копии данных вместо повторных обращений к серверу [^1].

**Кэширование** — это механизм, при котором результат запроса сохраняется и повторно используется, если он остаётся актуальным. В REST-архитектуре правильное использование кэша значительно повышает производительность и снижает нагрузку на сервер.

Как это выглядит:

- Если ресурс редко изменяется или не содержит персонализированной информации, сервер может добавить в ответ специальные HTTP-заголовки, например: `Cache-Control: max-age=600`. Это означает, что клиент может использовать кэшированную версию ресурса в течение 10 минут без повторного запроса. При последующих обращениях в этот период данные будут браться из локального кэша, что значительно ускоряет загрузку и экономит сетевые ресурсы.
- Если ресурс может изменяться, используются условные запросы, такие как: `If-Modified-Since`, `ETag`. В этом случае клиент спрашивает сервер: _«Изменились ли данные с тех пор?»_. Если нет — сервер возвращает `HTTP 304 Not Modified` (без тела ответа). Если да — отправляет обновлённую версию. Такой подход снижает объём передаваемых данных, сохраняя актуальность информации.
- Кэшируемость контролируется сервером. Например:
  - Ответы на `GET`-запросы могут кэшироваться, если сервер это разрешает.
  - Ответы на `POST` по умолчанию не кэшируются, так как предполагают изменение состояния.

Для ограничения кэширования сервер может указать, например: `Cache-Control: no-cache` или `Cache-Control: no-store` — это сообщает клиенту и промежуточным узлам, что кэшировать данные нельзя, что особенно важно для чувствительной или часто изменяющейся информации.

#### Пример на практике

Допустим, веб-сервис «Управление товарами» возвращает информацию о производителях товаров `GET /manufacturers`. Этот ресурс может редко меняться, и сервер может указать, что его можно кэшировать:

```http
Cache-Control: max-age=3600
```

Это означает, что клиент (например, браузер или мобильное приложение) может использовать закэшированный ответ в течение часа. При повторном запросе за тот же товар `GET /manufacturers` в течение этого времени клиент не будет обращаться к серверу повторно, а возьмёт данные из локального кэша. Это экономит ресурсы и ускоряет отклик.

Если же ресурс содержит динамичную информацию — например, детали текущей корзины: `GET /cart`, сервер, наоборот, запрещает кэширование, добавляя в заголовки: `Cache-Control: no-store, no-cache, must-revalidate`. Таким образом, клиент всегда будет обращаться к серверу, чтобы получить актуальные данные, и никогда не будет использовать устаревшую копию.

Важное следствие: в REST обычно GET-запросы не должны менять состояние (они безопасны, только получение). Это позволяет их спокойно кэшировать. В то время как метод `POST/PUT/DELETE/...` – модифицируют данные, их кэшировать нельзя (или очень ограниченно).

### 4. Единообразие интерфейса (Uniform Interface)

Это центральный принцип REST – наличие унифицированного интерфейса взаимодействия​. Он означает, что взаимодействие между клиентом и сервером должно происходить через единый, стандартизованный интерфейс, независимо от конкретного ресурса или его представления [^1]. Благодаря этому API становится понятным, предсказуемым и согласованным.

Про унифицированный интерфейс можно говорить долго. Рой Филдинг в своей диссертации выделил четыре ключевых свойства унифицированного интерфейса:

#### 1. Идентификация ресурсов

Каждый ресурс в системе должен быть однозначно идентифицирован. В контексте веба — это URI (или URL).

Например, ресурс "пользователь с ID 5" может быть представлен как:

```
/users/5
```

> [!IMPORTANT]
> URI определяет ресурс, а не его формат. Один и тот же ресурс можно получить как в JSON, так и в XML, но URL останется тем же.

#### 2. Манипуляции через представление ресурса

Клиент получает представление ресурса — например, данные о пользователе в формате JSON: `{ "id": 5, "name": "Alice" }`.

Если необходимо изменить эти данные, клиент отправляет обновлённую версию обратно на сервер, используя стандартные HTTP-методы:

- `PUT` — полная замена ресурса;
- `PATCH` — частичное обновление;
- `DELETE` — удаление ресурса.

Например, чтобы изменить имя пользователя на "Maria", клиент отправляет следующий запрос:

```http
PUT /users/5

{ "id": 5, "name": "Maria" }
```

Такой подход делает API предсказуемым и единообразным. Независимо от того, работаете ли вы с пользователями, товарами или заказами — принцип взаимодействия остаётся одинаковым: вы получаете данные, при необходимости изменяете их и отправляете обратно.

#### 3. Самоописываемость сообщений

Каждый запрос и ответ в себе несет информацию о том, как с ним обращаться, чтобы клиент понимал, как его интерпретировать — без внешней документации.

Примеры:

- Заголовок `Content-Type: application/json` сообщает, в каком формате содержимое.
- Код `404 Not Found` чётко говорит об ошибке, не требуя дополнительных пояснений.

Анти-паттерн:

```http
HTTP 200 OK
{"error": "not found"}
```

Такой ответ нарушает принцип REST — клиент не может полагаться только на статус-код.

#### 4. HATEOAS (Hypermedia as the Engine of Application State)

Это наиболее сложный и часто игнорируемый принцип. Идея: сервер сам подсказывает клиенту, какие действия возможны. Подобно тому, как пользователь кликает по ссылкам на сайте, клиент RESTful API должен «переходить по ссылкам» внутри ответа сервера. То есть сервер в ответах может давать ссылки на связанные ресурсы или доступные действия, а клиент, не зная заранее структуры API, следует по этим ссылкам.

Пример:

```json
{
  "products": [...],
  "next_page": "/products?page=2",
  "details": "/products/123"
}
```

Таким образом, **клиенту не нужно знать структуру API заранее** — он следует по гиперссылкам, полученным в ответах.

#### Единообразие на практике

**Единообразие интерфейса** – фундамент REST. Проще говоря, RESTful API должны быть построены по общим правилам, единым шаблонам. В хорошо спроектированном RESTful API это проявляется так:

- Стандартизированные URL:

  ```
  /users/5
  /users/5/orders
  /products/42
  ```

- Корректное использование методов HTTP

  - `GET` для получения ресурсов
  - `POST` для создания новых ресурсов
  - `PUT` для обновления существующих
  - `DELETE` для удаления

  _Плохая практика_:

  ```http
  POST /users/create
  ```

  — избыточно и нарушает единообразие. REST уже предполагает, что `POST /users` означает создание. Дополнительное слово create дублирует смысл метода и усложняет интерфейс.

- Предсказуемые коды и форматы ответов

  - Код `201 Created` при успешном создании
  - Код `204 No Content` при успешном удалении

- Документация API.

  - Понимая, как работает один ресурс, разработчик интуитивно понимает, как работать с другим. Не нужно каждый раз читать документацию — достаточно понимать шаблон.

#### Пример на практике

В рассмотренном примере веб-сервиса «Управление товарами», RESTful API можно реализовать следующим образом:

##### 1. Единая структура маршрутов\*\*

Все действия выполняются через понятные и стандартизированные URL и HTTP-методы:

```
GET    /api/products         — получить список товаров
POST   /api/products         — создать новый товар
GET    /api/products/123     — получить товар с ID 123
PUT    /api/products/123     — полностью обновить товар 123
PATCH  /api/products/123     — частично обновить товар 123
DELETE /api/products/123     — удалить товар 123
```

- Каждый маршрут начинается с /api/products,
- Идентификатор ресурса (`123`) идёт в конце,
- Метод чётко говорит, что происходит.

##### 2. Единообразный формат данных

Все ответы возвращаются в формате JSON и содержат понятные поля, например: `id, name, price, ...`. В заголовках ответа указывается: `Content-Type: application/json`.

1. Все URL начинаются с `/api/products`, идентификатор идет после слэша, методы соответствуют действиям. Ответы всегда в JSON и содержат, например, объекты с полями `id, name, price, ...`.

##### 3. Поддержка гипермедиа (HATEOAS)

Вы можете добавлять ссылки на другие ресурсы внутри ответа.

Например — ссылка на следующую страницу:

```json
{
  "products": [...],
  "links": {
    "next": "/api/products?page=2"
  }
}
```

Или — ссылка на связанные ресурсы (например, отзывы о товаре):

```json
{
  "id": 123,
  "name": "Кофеварка",
  "links": {
    "reviews": "/api/products/123/reviews"
  }
}
```

Такой подход делает API гибким и самодостаточным — клиент узнаёт, что можно делать дальше, прямо из ответа сервера.

##### 4. Предсказуемые коды ответа

- `200 OK — успешный запрос (например, список товаров).
- `201 Created — новый товар создан, в теле ответа — созданный объект.
- `204 No Content — товар успешно удалён, тело ответа не возвращается.
- `404 Not Found — товар не найден.
- `400 Bad Request — запрос был некорректным.
- `401 Unauthorized — клиент не авторизован.

Такой API легко использовать, масштабировать и документировать. Он следует принципу «_если ты понял один ресурс — ты понял все_».

### 5. Слоистая система (Layered System)

По REST, архитектура может состоять из слоёв, при этом каждый компонент системы видит только соседний слой, а деталей глубже не знает. Клиент может обращаться не напрямую к конечному серверу, а через ряд промежуточных узлов (прокси, балансировщики, шлюзы), при этом _никак не меняя своего поведения – посредники прозрачны_ [^1].

Примеры промежуточных слоёв:

- **Балансировщики нагрузки**. Получают запросы от клиентов и распределяют их между несколькими серверами. Клиент обращается к единому адресу, а какой сервер обслужит запрос — определяется внутренне, без участия клиента.
- **Кеш-прокси**. Хранят ответы от сервера и могут вернуть кэшированную копию без обращения к оригинальному источнику. Клиенту не важно, откуда пришёл ответ — из кеша или с сервера — он просто получает нужные данные.
- **Шлюзы, фильтры, фаерволы**. Могут выполнять аутентификацию, логирование, переадресацию запросов. Например, API-шлюз проверяет токен, а затем перенаправляет запрос на нужный внутренний сервис.
- **Микросервисы**. Внешний клиент взаимодействует с единым API-интерфейсом (например, через API Gateway), но за ним может скрываться сложная структура микросервисов, взаимодействующих между собой в несколько уровней.

Главное преимущество: **прозрачность**. Клиент не знает и не должен знать, сколько слоёв между ним и сервером. Он просто делает стандартный HTTP-запрос, используя единый интерфейс.

Это позволяет гибко масштабировать и модифицировать архитектуру, без необходимости менять клиентскую логику. Например, можно:

- Добавлять кеш,
- Распределять нагрузку,
- Встраивать системы безопасности,

#### Пример на практике

Предположим, ваш PHP-сервис не справляется с высокой нагрузкой. Чтобы улучшить производительность, вы решаете внедрить CDN [^2] (Content Delivery Network), например, Cloudflare, которая будет кэшировать статические ресурсы и частично разгружать ваш сервер.

Теперь, когда клиент отправляет запрос:

```
GET /api/products
```

— он попадает сначала не на ваш сервер, а на CDN. Если запрошенные данные есть в кэше CDN, то ответ формируется прямо там, без обращения к вашему серверу. Если данных нет — CDN передаёт запрос дальше, до источника (вашего PHP-сервиса).

При этом для клиента ничего не меняется: он получает тот же JSON-ответ, как и раньше, не зная о наличии промежуточного уровня.

Такая многоуровневая структура позволяет вам внедрять новые компоненты и оптимизации (CDN, прокси, шлюзы, балансировщики) без изменения клиентской части.

### 6. Код по требованию (Code on Demand) - _опционально_

Шестое и единственное необязательное ограничение REST — это "код по требованию". Оно означает, что сервер может передавать клиенту исполняемый код, чтобы расширить или изменить поведение клиента во время выполнения. Это ограничение применяется редко, но может быть полезно для повышения гибкости и динамичности взаимодействия.

Сервер по запросу может отправить клиенту:

- JavaScript, который клиент выполнит (в браузере),
- Скрипты или плагины, которые клиент может загрузить и использовать.
- другие исполняемые коды.

Например:

- API возвращает скрипт JavaScript, который клиент может использовать для локальной агрегации или валидации данных.
- Клиент получает правила расчёта, которые может выполнять "офлайн" без повторных запросов к серверу.

> [!NOTE]
> Рой Филдинг включил это ограничение в спецификацию REST как возможность, а не требование. Если ваш API не использует передачу исполняемого кода — это нормально. Вы просто не применяете опциональное расширение, и ваш API всё равно считается RESTful, если соблюдаются остальные пять обязательных ограничений.

#### Пример на практике

В теории ваш REST API, реализованный на PHP, может возвращать не только данные, но и исполняемый код. Например, при запросе: `GET /api/generateReport` вместо JSON-ответа сервер может вернуть JavaScript-код, который клиент затем выполнит для генерации отчёта на своей стороне. Такой подход крайне редок и скорее относится к "экзотическим" случаям применения REST. Более реалистичный и распространённый пример — если клиентом является веб-браузер. Он может отправить запрос: `GET /app.js`, и получить в ответ JavaScript-файл, который будет исполнен на клиентской стороне. Однако такой сценарий **чаще встречается в обычных веб-приложениях, а не в рамках чистых REST API**.

### Резюме

Резюмируя принципы: Если веб-сервис спроектирован с соблюдением всех описанных ограничений — клиент-сервер, stateless, cache, uniform interface, layered system, опционально code-on-demand — **то такой сервис можно считать RESTful**. По мнению Роя Филдинга, соблюдение этих принципов обеспечивает системе ключевые преимущества: простоту реализации и сопровождения, масштабируемость, высокую производительность, независимость между компонентами, возможность гибкой эволюции архитектуры. На практике многие современные веб-API стремятся следовать этим принципам, пусть и не всегда полностью.

В следующем разделе мы перейдём от архитектурных идей к практической реализации REST API.

## HTTP-методы в REST API

Одно из важных соглашений REST – использование стандартных HTTP-методов (глаголов HTTP) в соответствии с их семантикой. HTTP протокол предоставляет множество методов, но основные, которые используются в REST API: `GET`, `POST`, `PUT`, `PATCH`, `DELETE`, `OPTIONS` (а также реже `HEAD`).

HTTP-методы были рассмотрены в первых главах курса. В данной главе будут рассмотрены основные методы в контексте REST API.

Методы обладают свойствами, которые определяют их поведение:

- **Безопасность (safe)**. Методы, которые не изменяют данные (на стороне сервера) – например, `GET`, `HEAD`, `OPTIONS` должны быть «безопасными» (они только читают).
- **Идемпотентность (idempotent)**. Метод называется идемпотентным, если повторный вызов даёт тот же эффект, что и один. Например:
  - `PUT` — **идемпотентен**: если отправить одно и то же обновление 1 или 5 раз, результат будет одинаковым — ресурс просто перезаписывается.
  - `DELETE` — тоже идемпотентен: первый запрос удаляет ресурс, повторный ничего не меняет — ресурс уже удалён.
  - `POST` — неидемпотентен: каждый вызов может создавать новый объект. Повторный запрос может привести к дублированию.

Свойства безопасности и идемпотентности критичны для:

- надёжности (повтор запроса после сетевого сбоя),
- правильной кэшируемости,
- корректной маршрутизации запросов в распределённых системах.

_Например_, если после сбоя клиент не уверен, выполнился запрос или нет — **идемпотентный** запрос можно безопасно повторить. А вот **неидемпотентный** — повторять рискованно (может создать лишние записи или изменить данные повторно).

### GET

**GET** – метод для получения (чтения) ресурса. Запросы GET только извлекают данные, но не изменяют состояние на сервере [^3]. Поэтому GET – безопасный и кэшируемый метод. В REST через GET осуществляются запросы типа «получить ресурс или коллекцию ресурсов».

_Особенности_:

- `GET`-запрос не имеет тела (body); все параметры передаются через URL (query string) или заголовки.
- Запросы `GET` могут кэшироваться браузерами и прокси-серверами, если сервер это разрешает. Это повышает производительность и снижает нагрузку.
- Повторный `GET`-запрос не должен иметь побочных эффектов — браузер может автоматически отправить его повторно (например, при обновлении страницы).
- Из-за ограничения на длину URL GET не подходит для передачи больших объёмов данных — в таких случаях используют POST.

#### Пример обработки GET-запроса на PHP

```php
if ($_SERVER['REQUEST_METHOD'] === 'GET') {
    // Пример: получение списка фруктов
    $data = ["Apple", "Banana", "Cherry"];
    header("Content-Type: application/json");
    echo json_encode($data);
}
```

### POST

`POST` – метод для создания нового ресурса или выполнения действия на сервере. Он не идемпотентен и не безопасен, так как может изменять состояние сервера [^3].

> [!NOTE]
> Также POST применяется для любых операций, которые не подходят под остальные методы. По сути, POST – наиболее общий метод «отправить данные на сервер на обработку».

_Особенности_:

- `POST` может менять состояние на сервере (создавать, обновлять, вызывать действия). Это небезопасный метод.
- `POST` неидемпотентный: повторная отправка того же `POST` обычно приведет к созданию дубликата или повторному выполнению действия. Например, повторив `POST` на `/api/users` вы создадите два пользователя с одинаковыми данными.
- `POST`-запрос передает данные чаще всего в теле (body) запроса.
- Ответ на `POST` при успешном создании ресурса часто `201 Created` (с указанием URL нового ресурса в заголовке Location). Если POST использован для иных действий – может быть 200 OK или другой код.

#### Пример обработки POST-запроса на PHP

```php
if ($_SERVER['REQUEST_METHOD'] === 'POST') {
    // Читаем JSON из тела запроса
    $data = json_decode(file_get_contents('php://input'), true);
    // В реальности здесь бы сохраняли $newItem в базу или массив
    // Для примера просто вернем то же самое с новым ID
    $data['id'] = 4;  // предположим, присвоили ID 4
    header("Content-Type: application/json");
    http_response_code(201);  // Created
    echo json_encode($data);
}
```

### PUT

`PUT` – метод для обновления ресурса (или создания, если ресурса нет). Семантика `PUT` в REST: полностью заменить текущий ресурс данными из запроса [^3].

_Особенности_:

- `PUT` идемпотентен. Если вы несколько раз подряд отправите один и тот же `PUT` на один и тот же ресурс, эффект будет такой же, как от одного – ресурс в конечном итоге будет иметь те же данные.
- `PUT` требует, чтобы клиент отправил полный объект/ресурс. Например, если у пользователя есть 5 полей, все 5 должны быть в запросе, даже если изменилось только одно.
- Некоторые API позволяют `PUT` также для создания: например, `PUT /api/users/15` – если пользователя 15 нет, сервер может создать его с этими данными.
- Ответ на успешный `PUT`: либо `200 OK` (и можно вернуть обновленный ресурс), либо `204 No Content` (без тела, просто подтверждение). Если ресурс создан – `201 Created`.

#### Пример обработки PUT-запроса на PHP

```php
if ($_SERVER['REQUEST_METHOD'] === 'PUT') {
    // Предположим, URL вида /api/users/10
    // Получим ID из URL:
    $urlParts = explode('/', $_SERVER['REQUEST_URI']);
    $id = $urlParts[count($urlParts) - 1];  // очень упрощенно, последняя часть URL
    $input = file_get_contents('php://input');
    $updatedData = json_decode($input, true);
    // Здесь вы обновили бы пользователя $id в базе данными $updatedData
    // Допустим, успешно обновили:
    http_response_code(200);
    echo json_encode(["status" => "updated user $id"]);
}
```

### PATCH

`PATCH` – метод для частичного обновления ресурса. Он похож на PUT, но вместо замены всего ресурса, PATCH предполагает, что запрос содержит изменения, которые нужно применить к ресурсу​ [^3].

_Особенности_:

- В отличие от `PUT`, `PATCH` не обязателен быть идемпотентным – хотя обычно стараются сделать его идемпотентным, но семантически повторный `PATCH` может быть не совсем безопасен. _Например_, если патч описывает операцию (напр. _"увеличить значение на 5"_), то повторное выполнение даст другой результат.
- Ответ на `PATCH` часто `200 OK` (с возвращением ресурса обновленного) или `204 No Content`.

PATCH удобно использовать, когда у ресурса очень много полей и менять все не хочется, или когда отправка полного объекта затруднительна.

### Пример обработки PATCH-запроса на PHP

```php
if ($_SERVER['REQUEST_METHOD'] === 'PATCH') {
    $urlParts = explode('/', $_SERVER['REQUEST_URI']);
    $id = $urlParts[count($urlParts) - 1];
    $input = file_get_contents('php://input');
    $changes = json_decode($input, true);
    // Получаем существующего пользователя $id из базы (например, как массив $user)
    // Применяем изменения:
    // foreach ($changes as $field => $value) { $user[$field] = $value; }
    // Сохраняем $user обратно в базу.
    http_response_code(200);
    echo json_encode(["status" => "patched user $id"]);
}
```

> [!NOTE]
> Не все API реализуют PATCH, некоторые обходятся только PUT. Но PATCH – более точный инструмент для частичных изменений.

### DELETE

`DELETE` – метод для удаления ресурса [^3].

_Особенности_:

- `DELETE` идемпотентен: если ресурс уже удален, повторный DELETE обычно возвращает либо `404` (что в некотором смысле тоже можно считать “ничего не изменилось”), либо `204 No Content` без эффекта.
- Иногда `DELETE` не мгновенно уничтожает ресурс, а помечает как удаленный (_soft delete_). С точки зрения клиента, он удален (недоступен).
- `DELETE`-запросы не имеют тела (обычно). Просто метод и URL.

##### Пример обработки DELETE-запроса на PHP

```php
if ($_SERVER['REQUEST_METHOD'] === 'DELETE') {
    $urlParts = explode('/', $_SERVER['REQUEST_URI']);
    $id = $urlParts[count($urlParts) - 1];
    // Здесь вы удалили бы ресурс с данным $id из базы
    // Например, delete from users where id = $id
    http_response_code(204); // No Content
    // Обычно тело не возвращается при 204
}
```

#### OPTIONS

`OPTIONS` – вспомогательный метод, запрашивающий у сервера информацию о доступных возможностях (методах, опциях) на данном ресурсе [^3]. Например, клиент может узнать, какие методы поддерживаются для конкретного URL.

_Особенности_:

- OPTIONS сам по себе не меняет ничего – он `safe`.
- На запрос OPTIONS сервер обычно отвечает со статусом 204 и заголовком `Allow: GET,POST,OPTIONS,...` – перечисляя методы.

#### Пример обработки OPTIONS-запроса на PHP

```php
if ($_SERVER['REQUEST_METHOD'] === 'OPTIONS') {
    header("Allow: GET, POST, OPTIONS");
    header("Access-Control-Allow-Origin: *");
    header("Access-Control-Allow-Methods: GET, POST, OPTIONS");
    header("Access-Control-Allow-Headers: Content-Type");
    http_response_code(204);
    // нет тела ответа
}
```

## Реализация REST API на PHP

В этой главе мы рассмотрим, как реализовать REST API на PHP. В данной главе будет использован функциональный подход.

### Структура проекта

Для начала создадим структуру проекта. В корне создадим папку `api`, в ней создадим файл `index.php` и папку `products`. В папке `products` создадим файл `index.php` и файл `product.php`. Мы будем использовать единую точку входа `index.php`, которая будет обрабатывать все запросы к API. В итоге структура проекта будет выглядеть так:

```
api/
├── public/
│   └── index.php
├── src/
│   ├── handlers/
│   │   └── products/
│   │       └──  index.php
│   └── models/
│       └── product.php
```

### Основная логика

В файле `index.php` мы будем обрабатывать все запросы к API. Мы будем использовать метод `$_SERVER['REQUEST_METHOD']`, чтобы определить, какой метод был использован в запросе. В зависимости от метода мы будем вызывать соответствующий обработчик.

```php
<?php

// Устанавливаем заголовок Content-Type
header("Content-Type: application/json");
header("Access-Control-Allow-Origin: *");
header("Access-Control-Allow-Methods: GET, POST, PUT, PATCH, DELETE, OPTIONS");
header("Access-Control-Allow-Headers: Content-Type");

// Определяем запрошенный путь и метод
$method = $_SERVER['REQUEST_METHOD'];           // GET, POST, etc.
$uri = $_SERVER['REQUEST_URI'];                // например, "/api/books/3"

// Разбиваем путь на части
$uriParts = explode('/', trim($uri, '/'));     // ["books", "3"]
$resource = $uriParts[0] ?? '';                // "books"
$id = $uriParts[1] ?? null;                    // "3" (если есть)

// Простая маршрутизация:

if ($resource === "products") {
   // Подключаем обработчик для работы с книгами
   require_once __DIR__ . '/../src/handlers/products/index.php';

   // Вызов обработчика в зависимости от метода
   switch $method {
      case 'GET':
         handleGetBooks($id);
         break;
      case 'POST':
         handlePostBooks();
         break;
      case 'PUT':
         handlePutBooks($id);
         break;
      case 'PATCH':
         handlePatchBooks($id);
         break;
      case 'DELETE':
         handleDeleteBooks($id);
         break;
      default:
         http_response_code(405); // Method Not Allowed
         echo json_encode(["error" => "Method not allowed"]);
   }
}

http_response_code(404);
```

### Модель данных

В файле `models/product.php` определим функции для работы с базой данных.

```php
<?php

// models/product.php

// Предполагаем, что есть функция getPDOConnection() для получения соединения с БД

function getAllProducts() {
    $pdo = getPDOConnection();
    $stmt = $pdo->prepare("SELECT * FROM products");
    $stmt->execute();
    return $stmt->fetchAll(PDO::FETCH_ASSOC);
}

function getProductById($id) {
    $pdo = getPDOConnection();
    $stmt = $pdo->prepare("SELECT * FROM products WHERE id = :id");
    $stmt->bindParam(':id', $id);
    $stmt->execute();
    return $stmt->fetch(PDO::FETCH_ASSOC);
}

function createProduct($data) {
    $pdo = getPDOConnection();
    $stmt = $pdo->prepare("INSERT INTO products (name, price) VALUES (:name, :price)");
    $stmt->bindParam(':name', $data['name']);
    $stmt->bindParam(':price', $data['price']);
    $stmt->execute();
    return $pdo->lastInsertId();
}

function updateProduct($id, $data) {
    $pdo = getPDOConnection();
    $stmt = $pdo->prepare("UPDATE products SET name = :name, price = :price WHERE id = :id");
    $stmt->bindParam(':name', $data['name']);
    $stmt->bindParam(':price', $data['price']);
    $stmt->bindParam(':id', $id);
    return $stmt->execute();
}

function deleteProduct($id) {
    $pdo = getPDOConnection();
    $stmt = $pdo->prepare("DELETE FROM products WHERE id = :id");
    $stmt->bindParam(':id', $id);
    return $stmt->execute();
}
```

### Обработчики запросов

В файле `handlers/products/index.php` реализуем обработку запросов к ресурсу `products`.

```php
<?php

// handlers/products/index.php
require_once __DIR__ . '/../../models/product.php';

function handleGetProducts($id) {
    if ($id) {
        $product = getProductById($id);
        if ($product) {
            echo json_encode($product);
        } else {
            http_response_code(404);
            echo json_encode(["error" => "Product not found"]);
        }
        return;
    }
    $products = getAllProducts();
    echo json_encode($products);
}

function handlePostProducts() {
    $data = json_decode(file_get_contents('php://input'), true);

   $errors = [];

   if (!isset($data['name'])) {
      $errors['name'][] = "Name is required";
   }

   if (!isset($data['price']) || !is_numeric($data['price'])) {
    $errors['price'][] = "Price must be a valid number";
   } elseif ($data['price'] < 0) {
      $errors['price'][] = "Price must be greater than or equal to 0";
   }

   if (!empty($errors)) {
      http_response_code(400);
      echo json_encode(["errors" => $errors]);
      return;
   }

   $id = createProduct($data);
   http_response_code(201);
   echo json_encode(["id" => $id]);
}

function handlePutProducts($id) {
    $data = json_decode(file_get_contents('php://input'), true);
    if (updateProduct($id, $data)) {
        http_response_code(200);
        echo json_encode(["status" => "updated"]);
    } else {
        http_response_code(404);
        echo json_encode(["error" => "Product not found"]);
    }
}

function handleDeleteProducts($id) {
    if (deleteProduct($id)) {
        http_response_code(204);
    } else {
        http_response_code(404);
        echo json_encode(["error" => "Product not found"]);
    }
}
```

> [!IMPORTANT]
> Код приведен для понимания структуры; он упрощен (не оптимален) и не учитывает всех нюансов.

## Взаимодействие фронтенда с REST API

Создав RESTful API на сервере, нужно понимать, как им пользоваться с клиентской стороны. Часто клиенты – это веб-приложения (например, написанные на JavaScript), мобильные приложения или другой сервер. Здесь рассмотрим простой пример фронтенда на HTML/JS, который дергает REST API.

Предположим, у нас есть API по адресу `https://api.example.com` с ресурсом `/products`. Мы хотим на странице показать список книг, и добавить форму для добавления новой книги, отправляя данные на API.

### Пример HTML-страницы

```html
<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <title>Product List</title>
  </head>
  <body>
    <h1>Products</h1>
    <ul id="product-list"></ul>

    <h2>Add a new product</h2>
    <form id="product-form">
      <input type="text" name="title" placeholder="Title" required />
      <input type="number" name="price" placeholder="Price" required />
      <button type="submit">Add Product</button>
    </form>

    <script>
      const API_BASE = 'http://localhost/products';

      async function loadProducts() {
        try {
          const response = await fetch(API_BASE);
          if (!response.ok) {
            throw new Error('HTTP error ' + response.status);
          }
          const products = await response.json();
          const listEl = document.getElementById('product-list');
          listEl.innerHTML = ''; // clear current list
          products.forEach((product) => {
            const li = document.createElement('li');
            li.textContent = product.title + (product.price ? ' – ' + product.price : '');
            listEl.appendChild(li);
          });
        } catch (err) {
          console.error('Failed to load products:', err);
        }
      }

      loadProducts();

      document.getElementById('product-form').addEventListener('submit', async function (e) {
        e.preventDefault();
        const title = this.title.value;
        const price = this.price.value;
        try {
          const response = await fetch(API_BASE, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ title, price }),
          });
          if (response.ok) {
            const newProduct = await response.json();
            console.log('Product added:', newProduct);
            loadProducts();
            this.reset();
          } else {
            const errData = await response.json();
            alert('Error: ' + errData.error);
          }
        } catch (err) {
          console.error('Failed to add products:', err);
        }
      });
    </script>
  </body>
</html>
```

**Пояснения к коду**:

_Загрузка списка продуктов (`GET`)_

- В функции `loadProducts()` используется `fetch(API_BASE)`, чтобы отправить GET-запрос на адрес `API` (по умолчанию `fetch` делает `GET-запрос`).
- После получения ответа:
  - Проверяется `response.ok`, чтобы убедиться, что статус HTTP в диапазоне 200–299.
  - Затем вызывается `response.json()`, чтобы распарсить тело ответа в JavaScript-объект (массив продуктов).
- Продукты отображаются в виде элементов `<li>` внутри `<ul id="product-list">`.

_Добавление нового продукта (`POST`)_

- Форма с полями `title` и `price` перехватывает отправку через обработчик `submit`, чтобы не произошло перезагрузки страницы.
- Значения полей формы считываются и превращаются в объект.
- Отправляется `POST`-запрос на тот же URL `API_BASE`:
  - Указан метод `POST`.
  - Заголовок `Content-Type: application/json` сообщает серверу, что данные отправляются в формате JSON.
  - Тело запроса формируется с помощью `JSON.stringify({ title, price })`.
- После отправки:
  - Если ответ успешный (`response.ok`), вызывается `loadProducts()` — список обновляется, а форма сбрасывается.
  - Если сервер вернул ошибку (например, неверные данные), читается тело ответа и выводится сообщение об ошибке через `alert`.

### CORS (Cross-Origin Resource Sharing)

В примере используется:

```js
const API_BASE = 'http://localhost/api/products';
```

Но HTML-страница может находиться на другом домене, например `https://mysite.com`. В этом случае браузер по умолчанию заблокирует запрос, так как нарушается политика одного источника (`Same-Origin Policy`).

Эта политика — важный механизм безопасности в браузерах, который запрещает веб-страницам отправлять запросы к ресурсам на другом origin (то есть с другим протоколом, доменом или портом), если только сервер явно не разрешит это поведение.

**CORS (Cross-Origin Resource Sharing)** — это механизм, который позволяет серверу указать, каким внешним источникам (доменам) разрешено делать запросы к нему. Для этого сервер должен отправлять специальные HTTP-заголовки. Самый важный — это: `Access-Control-Allow-Origin: *`. Эта строка говорит браузеру: разрешено делать запросы с любого домена.

Чтобы включить поддержку CORS, достаточно добавить в ответ заголовок:

```PHP
header("Access-Control-Allow-Origin: *");
```

В реальных приложениях лучше указывать конкретные домены, которым разрешено делать запросы к вашему API. Либо если API публичный, то можно оставить `*`, чтобы разрешить доступ всем.

## Дополнительные рекомендации

### Использование префикса в URL

На практике REST API часто выделяют с помощью специального префикса в URL — например, `/api/...`. Это позволяет отделить программный интерфейс (API) от обычных веб-страниц сайта и избежать конфликтов маршрутов.

Пример:

- `https://example.com/api/users` — вызов к API (программа обращается к данным);
- `https://example.com/users` — обычная HTML-страница, предназначенная для пользователей.

### Версионирование API

Со временем любой API развивается: появляются новые поля, меняется логика, старые методы устаревают. Чтобы не ломать существующих клиентов, важно поддерживать версии API.

Наиболее распространённый способ — указание версии в URL-адресе:

- `https://api.example.com/api/v1/users` — первая версия API;
- `https://api.example.com/api/v2/users` — вторая версия, где, возможно, изменилась структура данных, например из `users` удалили поле `age`.

Если изменять существующий API, то это может привести к поломке старых клиентов, которые ожидают определённую структуру данных.

Такой подход позволяет клиентам переходить на новую версию API постепенно, без риска сломать уже работающие интеграции.

## Стоит ли строго соблюдать все REST-концепции?

На практике в веб-разработке давно сложилось понятие «достаточно RESTful». Многие API называют себя RESTful, даже если не реализуют все ограничения строго:

- не используют HATEOAS,
- применяют сессии (нарушая принцип stateless),
- имеют неидеальные URL-структуры,

— и при этом вполне успешно работают и остаются удобными для использования.

REST — это не догма, а набор архитектурных рекомендаций, которые помогают создавать масштабируемые и устойчивые API. Но как и в любой инженерной практике, иногда простое решение лучше теоретически «чистого», но сложного.

## Альтернативы REST

_REST – не единственный подход для построения веб-сервисов_. Кратко рассмотрим другие популярные варианты, их особенности и когда они могут быть предпочтительнее.

- **SOAP (Simple Object Access Protocol)** – это протокол для веб-сервисов, популярный в 2000-х годах и до сих пор используемый в enterprise-системах. В отличие от REST, SOAP – гораздо более строгий и сложный подход
- **GraphQL** – совсем другой подход, появившийся в 2015 году (разработан Facebook). Это не протокол как SOAP и не архитектурный стиль как REST, а язык запросов для API и соответствующая серверная исполняющая часть​. GraphQL позволяет клиенту запрашивать только те данные, которые ему нужны, и в том формате, который ему нужен.
- **gRPC** – фреймворк (RPC-библиотека) с открытым исходным кодом от Google (появился около 2015 г.), который реализует RPC (Remote Procedure Call) поверх современных технологий (HTTP/2, Protocol Buffers).

[^1]: _REST_. wikipedia [online resource]. Available at: https://en.wikipedia.org/wiki/REST
[^2]: CDN - это сеть серверов, расположенных в разных географических точках, которые кэшируют и доставляют контент пользователям с ближайшего к ним сервера. Это позволяет ускорить загрузку страниц и снизить нагрузку на основной сервер.
[^3]: _Методы HTTP запроса_. mdn [online resource]. Available at: https://developer.mozilla.org/ru/docs/Web/HTTP/Reference/Methods
