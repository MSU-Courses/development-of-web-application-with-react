# Маршрутизация в React

Маршрутизация в frontend-фреймворках, таких как React, отличается от маршрутизации в серверных приложениях. В серверных приложениях маршрутизация осуществляется на уровне сервера — он принимает запрос, определяет нужный маршрут и возвращает соответствующий ответ. В случае с React маршрутизация происходит на стороне клиента и отвечает за отображение соответствующих компонентов в зависимости от текущего URL.

## Зачем нужна маршрутизация в React?

Несмотря на то, что React изначально был создан для разработки одностраничных приложений (SPA — Single Page Application), в некоторых случаях возникает необходимость реализовать многостраничный интерфейс. _Например_, если у нас есть блог, мы хотим, чтобы в приложении были страницы **"Главная"**, **"О нас"**, **"Контакты"**, **"Статья"**, **"Автор** и другие. Для этого нам требуется маршрутизация.

Важно понимать, что даже при наличии нескольких страниц наше приложение по-прежнему остается одностраничным (SPA). Это означает, что при переходе между страницами перезагрузка страницы не происходит. Вместо этого React просто подменяет компоненты в зависимости от текущего URL, обеспечивая плавное и быстрое переключение.

## Как работает маршрутизация в React?

Когда пользователь переходит по определенному URL, React отображает соответствующий компонент без перезагрузки страницы. Это позволяет создавать приложения с быстрым и плавным интерфейсом.

**Например**:

- Если пользователь переходит по URL `/about`, React отображает компонент `About`.
- Если пользователь переходит по URL `/contacts`, отображается компонент `Contacts`.

## Компоненты-Страницы

С появлением маршрутизации в React возникает новое понятие — **компоненты-страницы**. Это компоненты, которые отображаются при переходе по определенному URL. Каждая страница приложения соответствует конкретному маршруту и отображается в зависимости от текущего URL.

### Структурная организация

Существует множество способов организации структуры приложения с маршрутизацией. Однако наиболее распространенным подходом является создание отдельной директории `pages`, в которой хранятся компоненты-страницы. Каждый файл в этой директории соответствует отдельной странице приложения.

Чтобы сразу было понятно, что компонент представляет собой страницу, рекомендуется использовать суффикс `Page` в названии компонента. Это делает код более понятным и структурированным.

**Пример 1**. _Структура директорий_

```
src/
  components/
    Button.jsx
    Header.jsx
    Footer.jsx
  pages/
    HomePage.jsx
    AboutPage.jsx
    ContactsPage.jsx
    ArticlePage.jsx
    AuthorPage.jsx
```

## Реализация маршрутизации в React (на чистом React)

Несмотря на то, что существует библиотеки для маршрутизации, такие как `react-router`, начнем с реализации маршрутизации на чистом React. Это поможет лучше понять принципы работы маршрутизации и как она интегрируется в React-приложение.

### Шаг 1. Создание компонентов-страниц

Создадим компоненты-страницы для каждой страницы приложения. В данном примере у нас будет две страницы: **Главная** и **О нас**.

**Пример 2**. _Компоненты-страницы_

```jsx
// src/pages/HomePage.jsx
import React from 'react';

const HomePage = () => {
  return (
    <div>
      <h1>Главная страница</h1>
      <p>Добро пожаловать!</p>
    </div>
  );
};

export default HomePage;
```

```jsx
// src/pages/AboutPage.jsx

import React from 'react';

const AboutPage = () => {
  return (
    <div>
      <h1>О нас</h1>
      <p>Мы — команда разработчиков, создающая крутые приложения!</p>
    </div>
  );
};

export default AboutPage;
```

### Шаг 2. Реализация маршрутизации

Для реализации маршрутизации в React нам потребуется создать компонент `App`, который будет отображать компоненты-страницы в зависимости от текущего `URL`. Для этого используем хук useState для хранения текущего маршрута и условный оператор `switch` (или `if`) для отображения соответствующего компонента.

**Пример 3**. _Реализация маршрутизации_

```jsx
import React, { useState } from 'react';
import HomePage from './pages/HomePage';
import AboutPage from './pages/AboutPage';

function App() {
  // Хранение текущего URL
  const [route, setRoute] = useState(window.location.pathname);

  // Функция для навигации по маршрутам
  const navigate = (path) => {
    window.history.pushState({}, '', path);
    setRoute(path);
  };

  // Отображение компонента-страницы в зависимости от текущего URL
  const renderPage = () => {
    switch (route) {
      case '/about':
        return <AboutPage />;
      default:
        return <HomePage />;
    }
  };

  return (
    <>
      <header>
        <nav>
          {/* 
            Навигация по маршрутам 
            При нажатии на кнопку происходит переход по соответствующему маршруту             
          */}
          <button onClick={() => navigate('/')}>Главная</button>
          <button onClick={() => navigate('/about')}>О нас</button>
        </nav>
      </header>
      <div>{renderPage()}</div>
      <footer>{/* ... */}</footer>
    </>
  );
}

export default App;
```

#### Пользовательский хук и маршруты в виде массива

Чтобы сделать код более гибким и структурированным, можно создать пользовательский хук для маршрутизации и хранить маршруты в виде массива. Это позволит легко управлять маршрутами и расширять их.

**Пример 4**. _Пользовательский хук для маршрутизации_

Файл `routes.js`:

```jsx
// routes.js

import HomePage from './pages/HomePage';
import AboutPage from './pages/AboutPage';

const routes = [
  {
    url: '/',
    component: <HomePage />,
  },
  {
    url: '/about',
    component: <AboutPage />,
  },
];

export default routes;
```

Файл `hooks/useRoutes.js`:

```jsx
// hooks/useRoutes.js

import { useState } from 'react';

const useRoutes = (routes) => {
  // Хранение текущего URL
  const [route, setRoute] = useState(window.location.pathname);

  const navigate = (path) => {
    // Изменение URL
    window.history.pushState({}, '', path);
    setRoute(path);
  };

  // Отображение компонента-страницы в зависимости от текущего URL
  const renderPage = () => {
    const routeConfig = routes.find((r) => r.url === route);
    return routeConfig ? routeConfig.component : <h2>404 - Страница не найдена</h2>;
  };

  return { navigate, renderPage };
};

export default useRoutes;
```

Файл `App.js`:

```jsx
import React from 'react';
import routes from './routes';
import useRoutes from './hooks/useRoutes';

function App() {
  const { navigate, renderPage } = useRoutes(routes);

  return (
    <>
      <header>
        <nav>
          <button onClick={() => navigate('/')}>Главная</button>
          <button onClick={() => navigate('/about')}>О нас</button>
        </nav>
      </header>
      <div>{renderPage()}</div>
      <footer>{/* ... */}</footer>
    </>
  );
}

export default App;
```

Теперь можно вынести компонент `Header` в отдельный файл и использовать внутри него функцию `navigate` для перехода по маршрутам.

### Недостатки такой реализации

Несмотря на то, что данная реализация маршрутизации работает и демонстрирует основные принципы, она имеет ряд недостатков:

- Отсутствие динамической маршрутизации (_например_, параметров в URL).
- Отсутствие обработки ошибок (_например_, несуществующий маршрут).
- Отсутствие встроенных функций для удобной навигации (_например_, переход по маршрутам и получение параметров).
- Отсутствие вложенных маршрутов, что ограничивает создание более сложных страниц с подмаршрутами.

> [!TIP]
> Для создания более мощной и гибкой маршрутизации в реальных приложениях рекомендуется использовать библиотеку `React Router` [^1]. Она предоставляет расширенные возможности, такие как динамические маршруты, вложенные маршруты, переходы и хук `useNavigate` для навигации по страницам.

## Использование библиотеки React Router

> [!NOTE]
> Напомним, библиотека - это набор готовых функций и компонентов, которые упрощают разработку приложений. В данном случае, библиотека `React Router` предоставляет удобные средства для реализации маршрутизации в React-приложениях.

### О библиотеке

**React Router** — это популярная библиотека для маршрутизации в React-приложениях. Она предоставляет удобные компоненты и хуки для создания динамических маршрутов, вложенных маршрутов, переходов и других возможностей, необходимых для управления навигацией в приложении.

React Router поддерживает три основных режима маршрутизации: [^2]:

- `Framework`. Используется для интеграции с фреймворками, такими как Next.js. Предназначен для создания маршрутов на уровне приложения с использованием серверного рендеринга.
- `Data`. Позволяет создавать маршруты на основе массива данных. Удобен для динамической генерации маршрутов из структурированных данных.
- `Declarative`. Позволяет создавать маршруты в декларативном стиле с использованием компонентов. Этот режим наиболее удобен для создания маршрутизации в чистых React-приложениях.

В данной теме мы будем использовать `Declarative` режим, так как он предоставляет удобный и наглядный способ создания маршрутов с помощью компонентов, что хорошо интегрируется с React-приложениями и делает код более читаемым и поддерживаемым.

### Установка

Для установки библиотеки `React Router` выполните следующую команду в терминале.

```bash
npm i react-router
```

Эта команда установит библиотеку `react-router`, которая включает компоненты и хуки для создания маршрутов в браузерных приложениях.

### Настройка маршрутизации

Для настройки маршрутизации оберните корневой компонент приложения (`App`) в компонент `BrowserRouter`, который предоставляет контекст маршрутизации для всех вложенных компонентов.

**Пример 5**. _Настройка маршрутизации_

```jsx
import React from 'react';

import ReactDOM from 'react-dom/client';
import { BrowserRouter } from 'react-router';
import App from './app';

const root = document.getElementById('root');

ReactDOM.createRoot(root).render(
  <BrowserRouter>
    <App />
  </BrowserRouter>,
);
```

### Создание маршрутов

Для создания маршрутов используйте компонент `Route` из библиотеки `react-router`. Каждый маршрут определяется с помощью:

- атрибута `path` - указывает на URL
- атрибута `element` - указывает на компонент, который должен отображаться при переходе по данному маршруту.

Обычно маршруты определяются в компоненте `App`, но в крупных приложениях маршруты могут быть вынесены в отдельный файл для лучшей структуризации.

**Пример 6**. _Создание маршрутов_

```jsx
import React from 'react';

import { Routes, Route } from 'react-router';

import HomePage from './pages/HomePage';
import AboutPage from './pages/AboutPage';

function App() {
  return (
    <Routes>
      <Route path="/" element={<HomePage />} />
      <Route path="/about" element={<AboutPage />} />
    </Routes>
  );
}
```

#### Использование `index`-маршрута

Для задания маршрута по умолчанию (например, домашней страницы) можно использовать атрибут `index` вместо явного указания пути:

**Пример 7**. _Использование `index`-маршрута_

```jsx
import React from 'react';

import { Routes, Route } from 'react-router';

import HomePage from './pages/HomePage';
import AboutPage from './pages/AboutPage';

function App() {
  return (
    <Routes>
      <Route index element={<HomePage />} />
      <Route path="/about" element={<AboutPage />} />
    </Routes>
  );
}
```

### Вложенные маршруты

React Router позволяет создавать вложенные маршруты, что упрощает создание сложных интерфейсов с иерархической структурой.

**Пример 8**. _Вложенные маршруты_

```jsx
import React from 'react';
import { Routes, Route } from 'react-router-dom';

import HomePage from './pages/HomePage';
import AboutPage from './pages/AboutPage';
import Articles from './pages/Articles';
import Article from './pages/Article';

function App() {
  return (
    <Routes>
      {/* index-маршрут для главной страницы: / */}
      <Route index element={<HomePage />} />
      <Route path="about" element={<AboutPage />} />

      {/* Вложенные маршруты */}
      <Route path="articles">
        {/* index-маршрут для списка статей: /article */}
        <Route index element={<Articles />} />
        <Route path=":id" element={<Article />} />
      </Route>
    </Routes>
  );
}

export default App;
```

Что происходит в примере:

- Маршрут `/articles` отображает компонент `Articles`, который представляет собой список статей.
- Маршрут `/articles/:id` отображает компонент `Article`, который принимает параметр `id` из URL.

Таким образом, при переходе по адресу `/articles/1` компонент `Article` получит параметр `id`, равный `1`.

### Использование `layout`-компонента

#### Проблема: отсутствие общего оформления

Представьте себе приложение с несколькими страницами, каждая из которых представляет собой отдельный компонент. Например:

- Главная страница (`HomePage`)
- Страница "О нас" (`AboutPage`)
- Страница статей (`ArticlesPage`)

При создании маршрутов без использования общего компонента макета (layout) каждая страница будет содержать собственные элементы навигации, хедеры и футеры. Это приводит к дублированию кода, снижению удобства поддержки и усложнению обновлений интерфейса.

Для решения данной проблемы можно использовать **компоненты-макеты** (**layout components**). Эти компоненты содержат общие элементы интерфейса, такие как шапка (header), подвал (footer), навигационное меню и область для отображения основного контента (той или иной страницы).

#### Что такое layout-компонент?

**Layout-компонент** — это обёртка, которая содержит общие для всех страниц элементы, такие как [^3]:

- Шапка (header)
- Навигационное меню
- Подвал (footer)
- и другие элементы интерфейса

Layout-компонент позволяет избавиться от дублирования кода и централизовать структуру приложения. Используя layout, мы можем оборачивать каждую страницу в общий каркас, чтобы избежать повторений и обеспечить единообразие оформления.

#### Использование layout-компонента

Чтобы создать удобный и централизованный макет для всех страниц приложения в React Router, используется компонент `Outlet`. Этот компонент представляет собой контейнер для отображения вложенных маршрутов, что позволяет легко создавать общий макет (layout) для всех страниц приложения.

**Пример 9**. _Использование layout-компонента_

Файл `layouts/AppLayout.jsx`:

```jsx
import { Outlet } from 'react-router';

// ...

function AppLayout() {
  return (
    <div>
      <Header />
      <Outlet />
      <Footer />
    </div>
  );
}

export default AppLayout;
```

Файл `App.js`:

```jsx
import { Routes, Route } from 'react-router';

// ...

function App() {
  return (
    <Routes>
      <Route element={<AppLayout />}>
        <Route index element={<HomePage />} />
        <Route path="about" element={<AboutPage />} />
        <Route path="articles" element={<ArticlePage />} />
      </Route>
    </Routes>
  );
}
```

В данном примере компонент `AppLayout` содержит общие элементы интерфейса, такие как шапка и подвал. Компоненты-страницы (`HomePage`, `AboutPage`, `ArticlePage`) динамически отображаются внутри layout-компонента с помощью компонента `Outlet`, который служит контейнером для вложенных маршрутов.

Концептуальная схема:

<img href="https://i.imgur.com/t3mJ1O5.png" width="850px" />

### Множество layout-компонентов

В некоторых случаях возникает необходимость использовать несколько layout-компонентов для различных разделов приложения. Это особенно полезно, когда нужно разграничить общие элементы интерфейса для разных частей приложения, например:

- Публичная часть (_например_, главная страница, информация о компании).
- Личный кабинет (_например_, панель управления, профиль пользователя).

Каждый раздел имеет свой набор страниц и собственный общий макет, обеспечивая структурированность и удобство в поддержке.

**Пример 10**. _Множество layout-компонентов_

Файл `App.jsx`:

```jsx
import { Routes, Route } from 'react-router';

// ...

function App() {
  return (
    <Routes>
      <Route element={<PublicLayout />}>
        <Route index element={<HomePage />} />
        <Route path="about" element={<AboutPage />} />
      </Route>
      <Route path="dashboard" element={<DashboardLayout />}>
        <Route index element={<DashboardPage />} />
        <Route path="profile" element={<ProfilePage />} />
      </Route>
    </Routes>
  );
}
```

В данном примере компонент `App` содержит два layout-компонента:

- `PublicLayout` — используется для публичной части приложения, включающей страницы **"Главная"** и **"О нас"**.
- `DashboardLayout` — применяется для личного кабинета, содержащего страницы **"Панель управления"** и **"Профиль пользователя"**.

Каждый layout-компонент определяет свой макет с общими элементами интерфейса. _Например_:

- Если пользователь переходит по адресу `/dashboard/*`, отображается layout `DashboardLayout` с соответствующими страницами.
- Если пользователь переходит по адресу `/` или `/about`, используется layout `PublicLayout`.

### Динамические маршруты

Динамические маршруты позволяют передавать параметры в URL и использовать их в компонентах-страницах. Это удобно, когда нужно отображать страницы на основе идентификаторов или других данных из адресной строки.

Для создания динамических маршрутов в React Router используется синтаксис `:param`, где param — любое имя параметра. Такой маршрут позволяет получить значение из URL и использовать его в компоненте.

**Пример 11**. _Динамические маршруты_

```jsx
import { Routes, Route } from 'react-router';

// ...

function App() {
  return (
    <Routes>
      <Route index element={<HomePage />} />
      <Route path="about" element={<AboutPage />} />
      <Route path="articles" element={<ArticlesPage />} />
      <Route path="articles/:id" element={<ArticlePage />} />
      <Route path="article/:id/edit" element={<EditArticlePage />} />
    </Routes>
  );
}

export default App;
```

В данном примере маршрут `/articles/:id` является динамическим и принимает параметр `id`. При переходе по адресу `/articles/1` компонент `ArticlePage` получит значение параметра `id`, равное `1`.

При использовании динамических маршрутов важно учитывать их порядок в списке маршрутов. Динамические маршруты должны располагаться в конце, чтобы избежать конфликтов с более общими маршрутами.

**Например**:

- Маршрут `/articles/create` должен находиться выше маршрута `/articles/:id`, чтобы не попадать под действие динамического маршрута.

Это позволяет избежать ситуаций, когда динамический маршрут перехватывает другие маршруты и препятствует их корректному отображению.

### Получение параметров из URL

Для получения параметров из URL в компоненте-странице используется хук `useParams` из библиотеки `react-router`. Этот хук позволяет получить значения параметров и использовать их в компоненте.

**Пример 12**. _Получение параметров из URL_

```jsx
import { useParams } from 'react-router';

function ArticlePage() {
  const { id } = useParams();

  return <div>Статья с идентификатором {id}</div>;
}
```

В данном примере хук `useParams` используется для получения параметра `id` из URL. При переходе по адресу `/articles/1` компонент `ArticlePage` отобразит текст `Статья с идентификатором 1`.

> [!NOTE]
> Параметры из URL всегда представляются в виде строк. При необходимости преобразования в другой тип данных (_например_, число) используйте соответствующие функции преобразования.

### Переходы между страницами

Для переходов между страницами в HTML обычно используется элемент `<a>`, который содержит атрибут `href` с адресом страницы. Однако при использовании такого подхода в React-приложении происходит полная перезагрузка страницы, что противоречит концепции одностраничных приложений (SPA).

В SPA при переходе между страницами приложение не должно перезагружаться, чтобы обеспечить плавность и скорость работы. Поэтому в React Router для создания переходов без перезагрузки страницы используется компонент `Link`, который содержит атрибут to с адресом маршрута. Этот компонент позволяет создавать ссылки между страницами с плавным переключением.

#### Использование компонента `Link`

Компонент `Link` предоставляет возможность осуществлять переходы между страницами без перезагрузки. Он заменяет стандартный HTML-тег `<a>` и позволяет сохранять состояние приложения при навигации.

**Пример 13**. _Переходы между страницами_

```jsx
import { Link } from 'react-router';

function Navigation() {
  return (
    <nav>
      <Link to="/">Главная</Link>
      <Link to="/about">О нас</Link>
      <Link to="/articles">Статьи</Link>
    </nav>
  );
}
```

#### Использование `NavLink`

​Компонент `NavLink` в React Router расширяет функциональность стандартного `Link`, позволяя автоматически применять стили к активной ссылке. Это особенно полезно для выделения текущего маршрута в навигационном меню.​

**Активная ссылка** — это ссылка, соответствующая текущему маршруту. Например, если пользователь находится на странице `/about`, то ссылка на страницу "О нас" должна быть выделена.

**Пример 14**. _Использование `NavLink`_

```jsx
import { NavLink } from 'react-router';

function Navigation() {
  return (
    <nav>
      <NavLink
        to="/"
        className={({ isActive, isPending }) => (isActive ? 'active' : isPending ? 'pending' : '')}>
        Главная
      </NavLink>
      <NavLink
        to="/about"
        className={({ isActive, isPending }) => (isActive ? 'active' : isPending ? 'pending' : '')}>
        О нас
      </NavLink>
      <NavLink
        to="/articles"
        className={({ isActive, isPending }) => (isActive ? 'active' : isPending ? 'pending' : '')}>
        Статьи
      </NavLink>
    </nav>
  );
}
```

В этом примере каждому `NavLink` присваивается функция `className`, которая принимает объект с состояниями `isActive` и `isPending`. Если ссылка активна (`isActive`), применяется класс `active`; если ожидается загрузка (`isPending`), применяется класс pending; в противном случае класс не присваивается. ​

Страница "Главная":

<img src="https://img001.prntscr.com/file/img001/bL-xTNyxSdyXWdgZ5jojIQ.png" width="500" />

Страница "О Нас":

<img src="https://img001.prntscr.com/file/img001/QO5F2yvpTpeBMYBQCwJusQ.png" width="500" />

#### Программная навигация с помощью `useNavigate`

Если необходимо выполнить переход между страницами программно, например, по событию или после выполнения определенного действия, используется хук `useNavigate`. Этот хук позволяет осуществлять навигацию без использования компонента `Link`.

**Пример 15**. _Программный переход_

```jsx
import { useNavigate } from 'react-router';

function Navigation() {
  const navigate = useNavigate();

  return (
    <nav>
      <button onClick={() => navigate('/')}>Главная</button>
      <button onClick={() => navigate('/about')}>О нас</button>
      <button onClick={() => navigate('/articles')}>Статьи</button>
    </nav>
  );
}
```

Функция `navigate` принимает строку с адресом маршрута и выполняет переход на указанную страницу. Это позволяет управлять навигацией в ответ на действия пользователя или другие события, например:

- После успешной отправки формы.
- После выполнения асинхронного запроса.
- При нажатии на кнопку.

## Recap: Маршрутизация в React

1. **Маршрутизация в React**:

   - Происходит на стороне клиента (SPA).
   - Позволяет переключать компоненты без перезагрузки страницы.

2. **Чистая маршрутизация в React**:

   - Использует состояние и методы навигации через `window.history.pushState`.
   - Простейший способ демонстрации маршрутизации.

3. **React Router**:

   - Гибкая библиотека для маршрутизации в React.
   - Основные компоненты: `Routes`, `Route`, `Link`, `NavLink`, `Outlet`.
   - Использует декларирование маршрутов с помощью компонентов.

4. **Layout-компоненты**:

   - Централизуют структуру страниц (общие элементы: header, footer, навигация).
   - Используют компонент `Outlet` для отображения вложенных маршрутов.
   - Облегчают поддержку и оформление приложения.

5. **Динамические маршруты**:

   - Позволяют передавать параметры через URL (`:param`).
   - Получение параметров с помощью хука `useParams`.
   - Динамические маршруты должны быть в конце списка для избежания конфликтов.

6. **Переходы между страницами**:

   - Компонент `Link` для плавных переходов.
   - Компонент `NavLink` для создания активных ссылок.
   - Хук `useNavigate` для программной навигации.

7. **Преимущества использования React Router**:
   - Простота и гибкость реализации маршрутов.
   - Динамическая маршрутизация и вложенные страницы.
   - Удобные переходы и активные ссылки.

[^1]: _React Router_. reactrouter.com [online resource]. Available at: https://reactrouter.com
[^2]: _Pick a Mode_. reactrouter.com [online resource]. Available at: https://reactrouter.com/start/modes
[^3]: _Website Layout_. sendpulse.com [online resource]. Available at: https://sendpulse.com/support/glossary/website-layout
[^4]: _Navigation_. reactrouter.com [online resource]. Available at: https://reactrouter.com/start/declarative/navigating
[^5]: _Nav Link_. reactrouter.com [online resource]. Available at: https://reactrouter.com/api/components/NavLink
