# Продвинутая оптимизация

> [!NOTE]
> Данная глава является дополнительной и не является обязательной для прохождения курса. Она предназначена для тех, кто хочет углубить свои знания в области оптимизации производительности React-приложений и изучить более продвинутые техники.

В предыдущей главе мы рассмотрели три базовых инструмента оптимизации React-приложений: `React.memo`, `useCallback` и `useMemo`. Они помогают избегать лишних рендеров и повторных вычислений.

В этой главе мы кратко познакомимся с более продвинутым подходом — управлением приоритетами обновлений с помощью хука `useTransition`, появившегося в React 18.

## useTransition: приоритеты рендера

Хук `useTransition` [^1] относится к классу приоритетных оптимизаций. В отличие от `React.memo` и `useCallback`, которые предотвращают ненужные рендеры, `useTransition` работает с теми рендерами, которые всё же необходимо выполнить — но не обязательно немедленно.

**React позволяет разделить обновления на**:

- **Срочные (urgent)** — напрямую влияющие на отклик интерфейса;
- **Фоновые (non-urgent / transition)** — тяжёлые, но не критичные для мгновенного отображения.

Если вы когда-либо бывали в отделении скорой помощи, то знаете, что пациентов сортируют по уровню приоритета. _Например_, сломанная нога попадает в "зелёную зону" — это неотложный, но не критический случай. А вот сердечный приступ — это "красная зона", и помощь требуется немедленно. Также работают приоритеты в React: фоновые,- зеленая зона, и срочные обновления,- красная зона.

### Зачем нужен `useTransition`?

Представьте, что пользователь вводит текст в поле поиска, и приложение должно сразу отфильтровать и отобразить данные из большого списка.

Без оптимизации каждое нажатие клавиши будет вызывать пересчёт и ререндер всего списка — интерфейс начнёт лагать, потому что React пытается всё отрисовать немедленно.

С помощью `useTransition` мы можем сказать:

```
«Ввод текста — это срочно, а вот фильтрация и обновление списка — можно сделать в фоне».
```

В результате React выполнит критические обновления (ввод, клики, навигацию) в первую очередь, а остальное — чуть позже, в «свободное» время, без блокировки интерфейса.

> [!IMPORTANT]
> Хук `useTransition` не отменяет само вычисление и не делает его быстрее – оно лишь даёт React возможность оптимальнее расставить приоритеты. . Это полезно, когда у вас есть серьёзно нагружающие рендер задачи (большие списки, графики, карты), и вы хотите избежать фризов. Но не стоит помечать все обновления как некритичные – иначе интерфейс начнёт откликаться с задержкой повсюду.

### Синтаксис useTransition

```jsx
const [isPending, startTransition] = useTransition();
```

- `startTransition(() => { ... })` — запускает обновление с низким приоритетом.
- `isPending` — булевое значение: показывает, выполняется ли сейчас фоновое обновление. Это удобно для показа индикатора загрузки или "скелетонов".

### Пример использования

Допустим, у нас есть список из 10 000 элементов, и пользователь фильтрует его через текстовое поле. При каждом вводе символа запускается фильтрация. Если всё выполнять напрямую — интерфейс начинает тормозить, особенно при быстром вводе. С `useTransition` же всё работает плавно: React сначала обрабатывает ввод, а затем — тяжёлую фильтрацию.

**Пример 1**. _Рендер списка без useTransition_

```jsx
import { useState } from 'react';

function App() {
  const [input, setInput] = useState('');
  const [list, setList] = useState([]);

  const handleChange = (e) => {
    const value = e.target.value;
    setInput(value);

    // Тяжёлая операция — фильтрация большого массива
    const filtered = bigList.filter((item) => item.toLowerCase().includes(value.toLowerCase()));
    setList(filtered);
  };

  return (
    <div>
      <input value={input} onChange={handleChange} placeholder="Поиск..." />
      <ul>
        {list.map((item) => (
          <li key={item}>{item}</li>
        ))}
      </ul>
    </div>
  );
}

// Генерация большого списка
const bigList = Array.from({ length: 10000 }, (_, i) => `Элемент ${i + 1}`);
```

**Проблема**: при каждом нажатии клавиши сразу происходит пересчёт и перерисовка всего списка. Если пользователь вводит быстро — появляются лаги и фризы. Интерфейс становится менее отзывчивым.

**Пример 2**. _Оптимизация с useTransition_

```jsx
import { useState, useTransition } from 'react';

function App() {
  const [input, setInput] = useState('');
  const [list, setList] = useState([]);
  const [isPending, startTransition] = useTransition();

  const handleChange = (e) => {
    const value = e.target.value;
    setInput(value); // Высокий приоритет: UI реагирует мгновенно

    startTransition(() => {
      // Низкий приоритет: фильтрация выполняется в фоне
      const filtered = bigList.filter((item) => item.toLowerCase().includes(value.toLowerCase()));
      setList(filtered);
    });
  };

  return (
    <div>
      <input value={input} onChange={handleChange} placeholder="Поиск..." />
      {isPending && <p>Загрузка...</p>}
      <ul>
        {list.map((item) => (
          <li key={item}>{item}</li>
        ))}
      </ul>
    </div>
  );
}

const bigList = Array.from({ length: 10000 }, (_, i) => `Элемент ${i + 1}`);
```

Преимущества использования `useTransition`:

- Ввод текста остаётся мгновенным, без подвисаний.
- Фильтрация выполняется в фоне, не мешая взаимодействию с интерфейсом.
- Можно отобразить индикатор `Загрузка...`, пока идёт тяжёлая операция.

В рамках нашего курса достаточно знать, что `useTransition` существует и решает задачи приоритетов рендера. Детальное применение этого хуки вы сможете изучить, когда столкнётесь с необходимостью оптимизировать действительно тяжёлые обновления в приложении.

> [!NOTE]
> Помимо `useTransition`, в React также существует похожий хук `useDeferredValue`, который позволяет отложить обновление значения, чтобы приоритетные части интерфейса (_например_, ввод в поле) отрисовывались быстрее. Это особенно полезно при работе с большими списками или таблицами. Если Вам интересно, можете ознакомиться с данным хуком:
> Документация React [^2]
> Статья на Хабре [^1]

[^1]: _Оптимизация React-приложений: Используем useTransition, useDeferredValue и useOptimistic для плавного UI_. habr.com [online resource]. Available at: https://habr.com/ru/articles/870748/
[^2]: _useDeferredValue_. react.dev [online resource]. Available at: https://react.dev/reference/react/useDeferredValue
[^3]: _useTransition_. react.dev [online resource]. Available at: https://react.dev/reference/react/useTransition
