# Инструменты оптимизации: как избегать лишних ререндеров

Теперь перейдём к методам оптимизации, позволяющим избегать подобных ситуаций. В React есть несколько средств, чтобы компонент рендерился повторно только при необходимости.

Рассмотрим три основных инструмента для функциональных компонентов: `React.memo`, `useMemo` и `useCallback`.

## Что такое мемоизация?

Прежде чем переходить к инструментам оптимизации, важно разобраться с понятием мемоизация, так как оно будет встречаться в следующих разделах.

**Мемоизация** — это техника оптимизации, при которой результат функции сохраняется (кешируется), и при повторных вызовах с теми же аргументами возвращается уже сохранённый результат вместо повторного вычисления.

> [!NOTE]
> Мемоизация работает только для чистых функций, то есть функций, которые всегда возвращают один и тот же результат для одинаковых входных данных и не имеют побочных эффектов.

_Например_, есть функция `f(num)`, которая при значении `num=5` возвращает 10, но её выполнение занимает много времени. Решением в такой ситуации является выполнить функцию один раз, сохранить результат в кэше под ключом 5, а при повторном вызове с тем же значением сразу вернуть сохранённый результат — без повторного запуска функции. Именно так работает _мемоизация_: она позволяет избежать лишних вычислений при повторных обращениях с одинаковыми данными.

**Пример 1**. _Мемоизация функции на чистом JavaScript_

```javascript
function slowFunction(num) {
  console.log('Выполняется...');
  return num * 2;
}

const memoized = (() => {
  const cache = {};
  return function (num) {
    if (cache[num]) {
      return cache[num];
    }
    const result = slowFunction(num);
    cache[num] = result;
    return result;
  };
})();

console.log(memoized(5)); // "Выполняется...", 10
console.log(memoized(5)); // 10
```

Процесс мемоизации используется и в React для оптимизации производительности. _Например_, компонент в React — это, по сути, обычная функция, которая возвращает JSX. Поэтому к нему также можно применить мемоизацию, чтобы избежать повторного рендеринга, если входные данные (пропсы) не изменились.

## React.memo: мемоизация компонентов

`React.memo` [^5] — это функция (HOC, _higher-order component_ [^1]), которая оборачивает функциональный компонент и изменяет его поведение: теперь компонент будет сравнивать свои пропсы при каждом рендере и перерисовываться только если они изменились [^2]. Проще говоря, `React.memo` делает компонент _"чистым" по пропсам_: если входные данные (пропсы) остались теми же, React использует результат предыдущего рендера из кеша и не вызывает компонент повторно.

Применим `React.memo` к компоненту `Counter` из предыдущего примера (1).

**Пример 2**. _Использование React.memo для оптимизации рендеринга_

```jsx
const Counter = React.memo(({ name, value }) => {
  console.log(`Rendering counter ${name}`);
  return (
    <div>
      {name}: {value}
    </div>
  );
});
```

Теперь компонент `Counter` будет повторно рендериться только если изменятся его пропсы `name` или `value`. Поведение приложения останется прежним: оба счётчика отображаются и работают как и раньше. Однако в консоли, при нажатии на кнопку **«Увеличить A»**, мы увидим:

```
Click button
Rendering counter A
```

**Счётчик B больше не рендерится**! Благодаря `React.memo` React сравнил пропсы `CounterB` до и после рендера (`name="B"` и `value=0`) и понял, что они не изменились — повторный вызов функции компонента не потребовался. **Итог**: `React.memo` успешно предотвратил лишний рендеринг компонента `CounterB`, тем самым улучшив производительность (_улучшил ли?_).

> [!IMPORTANT]  
> Важно понимать, что `React.memo` выполняет **поверхностное сравнение пропсов**.  
> Он сравнивает примитивные значения (числа, строки, булевы) **по значению**, а объекты и функции — **по ссылке**.
>
> Это означает, что если пропс — это объект или функция, то даже при одинаковом содержимом новая ссылка будет отличаться от старой. В результате такой пропс считается изменившимся, и компонент перерисуется.
>
> В подобных случаях `React.memo` **без дополнительных настроек не поможет**. Однако для более точного контроля можно передать вторым аргументом свою функцию сравнения: `React.memo(Component, arePropsEqual)`
>
> Использование собственной функции сравнения (`arePropsEqual(prevProps, nextProps)`) может быть полезным, но требуется достаточно редко — в основном, когда нужно оптимизировать «тяжёлые» компоненты с часто обновляемыми сложными пропсами [^3].

### Всегда ли использовать React.memo?

На первый взгляд может показаться, что `React.memo` — универсальный способ оптимизации: достаточно обернуть им все компоненты, и можно забыть о лишних рендерах. Но это не так. `React.memo` не всегда приводит к улучшению производительности — и в некоторых случаях может даже её ухудшить.

#### Когда использовать `React.memo`?

Этот инструмент особенно полезен для компонентов, которые:

- **Трудоёмкие в рендеринге**. Содержат много JSX, сложную логику или большое дерево вложенных элементов.
- **Часто получают одни и те же пропсы**. _Например_, в списке из 1000 элементов изменяется только один. Остальные 999 получают прежние данные и могут не перерисовываться.
- **Редко меняют свои пропсы**. Если компонент чаще рендерится с теми же самыми пропсами, чем с новыми — его стоит мемоизировать.

Хотя `React.memo` может сократить количество рендеров, _сравнение пропсов при этом всё равно выполняется — и тоже требует ресурсов_. Это небольшая нагрузка, но при массовом и необоснованном использовании (на всякий случай) она может стать заметной. React по умолчанию и так работает достаточно эффективно. Поэтому в простых компонентах или тех, что всегда получают новые пропсы, использование `React.memo` не только бесполезно, но и может слегка замедлить рендеринг.

> [!NOTE]
> Например, в примере (2) с `Counter` использование `React.memo` не дало бы заметного эффекта с точки зрения производительности. Компонент `Counter` очень простой: он выводит две строки текста и не содержит тяжёлых вычислений или вложенных компонентов. Даже если он рендерится лишний раз — это происходит быстро и почти незаметно.

Мы ещё вернёмся к вопросу: когда оптимизация действительно оправдана, а когда она только усложняет код без практической пользы.

## useCallback: мемоизация функций

Второй ключевой инструмент оптимизации в React — это хук `useCallback` [^6]. Его задача — вернуть ту же самую функцию между рендерами, если не изменились её зависимости [^2]. Это решает одну из типичных проблем: постоянно меняющиеся ссылки на функции-колбэки.

Во многих случаях это не вызывает проблем. Но если такая функция передаётся в дочерний компонент через props, возникает следующий сценарий:

```
Родитель рендерится → создаётся новая функция → дочерний получает "новый" пропс → происходит лишний ререндер.
```

Даже если функция делает то же самое, React воспринимает её как новую из-за новой ссылки в памяти.

**Пример 3**. _Проблема с лишним рендером_

```jsx
function List({ items, onItemClick }) {
  console.log('List render');
  // ... рендер списка с элементами и привязкой onItemClick к каждому
}

const items = ['A', 'B', 'C'];

function App() {
  const [count, setCount] = useState(0);

  const handleClick = (item) => {
    console.log('Clicked', item);
  };

  return (
    <>
      <button onClick={() => setCount(count + 1)}>Increment</button>
      <List items={items} onItemClick={handleClick} />
    </>
  );
}
```

Здесь функция `handleClick` объявлена внутри `App`, поэтому при каждом рендере создаётся новая ссылка. Даже если логика не изменилась, для React это уже другая функция.

_Например_:

- при первом рендере `handleClick` имеет ссылку `0x123` (_адрес функции в памяти_),
- при следующем — уже `0x456` (хотя логика внутри функции не изменилась).

В результате при каждом нажатии на кнопку `Increment` компонент `App` рендерится заново, создаёт новую функцию `handleClick`, и компонент `List` получает новый пропс `onItemClick`. Это приводит к лишнему ререндеру `List`, несмотря на то, что массив `items` остался прежним (_он объявлен вне App и не пересоздается_), а логика функции `handleClick` по сути не изменилась.

Чтобы избежать этого, можно использовать `useCallback`, который вернёт ту же самую функцию при каждом рендере, если не изменились её зависимости.

**Пример 4**. _Оптимизация с помощью useCallback_

```jsx
function App() {
  const [count, setCount] = useState(0);
  const items = ['A', 'B', 'C'];

  const handleClick = useCallback((item) => {
    console.log('Clicked', item);
  }, []); // зависимостей нет, функция будет одна для всех рендеров

  return (
    <>
      <button onClick={() => setCount(count + 1)}>Increment</button>
      <List items={items} onItemClick={handleClick} />
    </>
  );
}
```

_В данном примере_:

- Мы обернули колбэк `handleClick` в `useCallback` с пустым массивом зависимостей (`[]`).
- Это означает, что функция будет создана один раз при первом рендере и будет использоваться повторно при следующих рендерах — до тех пор, пока зависимости не изменятся (а в данном случае они отсутствуют).

Теперь при нажатии на кнопку `Increment` компонент `App` всё так же будет рендериться (потому что изменяется состояние `count`), но функция `handleClick` останется прежней. А значит, компонент `List` получит ту же самую ссылку на пропс `onItemClick` и не будет перерисован лишний раз.

> [!IMPORTANT]
> Хук `useCallback` мемоизирует саму функцию, но не её работу. Он не делает вашу функцию «быстрее», он просто возвращает ту же самую функцию, если зависимые от неё значения не изменились.

В предыдущем примере зависимостей не было — функция `handleClick` не использовала никаких данных из компонента. Поэтому она сохраняется одной и той же на протяжении всего жизненного цикла компонента.

Но на практике колбэк часто зависит от каких-то данных — например, от состояния. В таких случаях зависимости обязательно нужно указывать. Допустим, если бы `handleClick` использовал `count`, код выглядел бы так:

```jsx
const handleClick = useCallback(
  (item) => {
    console.log('Count is', count, 'Clicked', item);
  },
  [count],
);
```

Теперь при каждом изменении count хук `useCallback` будет возвращать новую версию функции. Это нужно для того, чтобы внутри колбэка всегда был доступен актуальный `count`.

> [!WARNING]
> Если бы мы не указали `count` в списке зависимостей, внутри функции оставалось бы старое значение — и при каждом вызове колбэка выводился бы устаревший `count`.

Несмотря на использование `useCallback`, компонент `List` всё равно будет перерисовываться, если не обёрнут в `React.memo`.

Дело в том, что `useCallback` лишь сохраняет одну и ту же ссылку на функцию между рендерами, но сам по себе не предотвращает рендер дочернего компонента. Чтобы это работало, нужен `React.memo`, который сравнит пропсы и решит — нужно ли выполнять рендер.

На практике `React.memo` и `useCallback` часто применяются в паре:

- `React.memo` предотвращает лишние рендеры компонента, если его пропсы не изменились.
- `useCallback` позволяет сохранить одну и ту же функцию между рендерами, чтобы `React.memo` увидел, что этот пропс не изменился по ссылке.

**Пример 5**. _Использование React.memo и useCallback вместе_

```jsx
// Добавляем мемоизацию в компонент List
const List = React.memo(({ items, onItemClick }) => {
  console.log('List render');
  // ... рендер списка с элементами и привязкой onItemClick к каждому
});

// Функция App из предыдущего примера (4)
```

**Вывод**: `useCallback` позволяет устранить причину лишнего ререндера, сохранив ссылочную равенство пропса между рендерами. Но чтобы был эффект, компонент-получатель должен быть оптимизирован (мемоизирован) и учитывать эту ссылку.

## useMemo: мемоизация значений - оптимизация тяжёлых вычислений

Хук `useMemo` [^7] позволяет кэшировать (запоминать) результат тяжёлых вычислений между рендерами компонента. Это нужно для того, чтобы не пересчитывать результат заново каждый раз, если входные данные не изменились.

Проще говоря, `useMemo` — это аналог `React.memo`, но не для компонентов, а для обычных вычислений внутри компонента. Фактически, это чистый механизм мемоизации, о котором мы говорили в разделе: [Что такое мемоизация?](#что-такое-мемоизация).

Также useMemo во многом похож на useCallback, но вместо функций мы мемоизируем значения.

### Когда useMemo действительно полезен?

`useMemo` нужен в ситуациях, когда при каждом рендере выполняются тяжёлые или затратные операции, _например_:

- фильтрация или сортировка большого массива,
- построение сложного объекта,
- форматирование дат, вычисление промежуточных данных и т.п.

Даже если входные данные остались прежними, без `useMemo` вычисления будут выполняться заново на каждый рендер. Это лишняя работа, которую можно легко избежать с помощью мемоизации.

### Концептуальный пример использование useMemo

Представим, что у нас есть компонент, который должен вычислить факториал числа. Само по себе это простая математическая функция, но при работе с большими числами её выполнение может занять значительное время.

> [!NOTE]
> Хотя в реальных приложениях такие задачи встречаются редко, это хороший пример, чтобы наглядно показать, как работает `useMemo` и зачем он нужен.

**Пример 6**. _Компонент без использования useMemo_

```jsx
import { useState } from 'react';

function FactorialCalculator() {
  const [number, setNumber] = useState(100000);
  const [otherState, setOtherState] = useState(false);

  // Тяжёлое вычисление — без мемоизации
  const factorial = (() => {
    console.log('Вычисляется факториал...');
    let result = 1;
    for (let i = 1; i <= number; i++) {
      result *= i;
    }
    return result;
  })();

  return (
    <div>
      <h2>Факториал числа {number}</h2>
      <p>Результат: {factorial}</p>
      <button onClick={() => setNumber((prev) => prev + 1)}>Увеличить число</button>
      <button onClick={() => setOtherState((prev) => !prev)}>Обновить другое состояние</button>
    </div>
  );
}
```

В этом примере при каждом рендере компонента (даже если `number` не изменился), функция пересчитывает факториал заново. _Например_, изменение другого состояния (`otherState`) также приведёт к выполнению тяжёлого кода — что может негативно сказаться на производительности.

**Пример 7**. _Оптимизация с помощью useMemo_

```jsx
import { useMemo, useState } from 'react';

function FactorialCalculator() {
  const [number, setNumber] = useState(100000);
  const [otherState, setOtherState] = useState(false);

  const factorial = useMemo(() => {
    console.log('Вычисляется факториал...');
    let result = 1;
    for (let i = 1; i <= number; i++) {
      result *= i;
    }
    return result;
  }, [number]);

  return (
    <div>
      <h2>Факториал числа {number}</h2>
      <p>Результат: {factorial}</p>
      <button onClick={() => setNumber((prev) => prev + 1)}>Увеличить число</button>
      <button onClick={() => setOtherState((prev) => !prev)}>Обновить другое состояние</button>
    </div>
  );
}
```

Теперь тяжёлое вычисление будет выполняться только тогда, когда изменяется `number`. При изменении других частей состояния (`otherState`), компонент перерисуется, но `factorial` останется прежним — React просто возьмёт сохранённое значение из кеша.

### Примеры использования useMemo

В реальных приложениях, одним из частых сценариев использования `useMemo` является фильтрация массива по определенному условию. _Например_, компонент, который отображает список элементов и фильтрует их по `searchTerm`, введённому пользователем.

**Пример 8**. _Компонент без оптимизации — фильтрация при каждом рендере_

```jsx
function SearchableList({ items, searchTerm }) {
  const filteredItems = items.filter((item) =>
    item.toLowerCase().includes(searchTerm.toLowerCase()),
  );

  return (
    <ul>
      {filteredItems.map((item) => (
        <li key={item}>{item}</li>
      ))}
    </ul>
  );
}
```

В этом примере при каждом рендере компонента выполняется `.filter()`, даже если `items` и `searchTerm` не изменились. Это неэффективно, особенно если список большой или компонент рендерится часто.

**Пример 7**. _Оптимизированный компонент — мемоизация фильтрации с помощью useMemo_

```jsx
import { useMemo } from 'react';

function SearchableList({ items, searchTerm }) {
  const filteredItems = useMemo(() => {
    return items.filter((item) => item.toLowerCase().includes(searchTerm.toLowerCase()));
  }, [items, searchTerm]);

  return (
    <ul>
      {filteredItems.map((item) => (
        <li key={item}>{item}</li>
      ))}
    </ul>
  );
}
```

Теперь фильтрация будет происходить только тогда, когда изменится массив `items` или значение `searchTerm`. Если же компонент рендерится по другой причине (_например_, обновляется состояние родителя), React просто возьмёт результат из кеша и не будет выполнять `.filter()` заново.

### useMemo для мемоизации JSX-элементов

Хук `useMemo` можно использовать не только для чисел, строк и объектов, но и для мемоизации JSX-элементов. Это бывает полезно, когда результат JSX содержит:

- тяжёлые вычисления,
- объёмные данные (например, таблицы),
- компоненты со сложной логикой.

В таких случаях `useMemo` позволяет избежать повторного создания JSX-элементов при каждом рендере, если входные данные не изменились.

**Пример 9**. _ Компонент без мемоизации — тяжёлый JSX генерируется при каждом рендере_

```jsx
// Предполагается, что data — это большой массив объектов
function Dashboard({ data }) {
  return (
    <div>
      <h1>Отчёт</h1>
      <table>
        <tbody>
          {data.map((row) => (
            <tr key={row.id}>
              <td>{row.name}</td>
              <td>{row.value}</td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
}
```

В этом примере при каждом рендере компонента пересоздаётся весь массив строк таблицы (`<tr>` и `<td>`), даже если `data` не изменилась. Если таблица большая — это может стать ощутимой нагрузкой на производительность.

**Пример 10**. _Мемоизация JSX с помощью useMemo_

```jsx
import { useMemo } from 'react';

function Dashboard({ data }) {
  const tableRows = useMemo(() => {
    return data.map((row) => (
      <tr key={row.id}>
        <td>{row.name}</td>
        <td>{row.value}</td>
      </tr>
    ));
  }, [data]); // пересоздание — только при изменении data

  return (
    <div>
      <h1>Отчёт</h1>
      <table>
        <tbody>{tableRows}</tbody>
      </table>
    </div>
  );
}
```

Теперь массив JSX-элементов (`<tr>`) сохраняется между рендерами, и React пересоздаёт его только в случае изменения `data`. Это позволяет сократить количество лишней работы и ускорить рендеринг компонента.

Хотя `useMemo` — удобное решение, в подобных случаях часто лучше использовать вынос тяжёлой части JSX в отдельный компонент и обернуть его в `React.memo`. Это делает код более читаемым и масштабируемым:

**Пример 11**. _Компонент с мемоизацией через React.memo_

```jsx
const TableRows = React.memo(({ data }) => {
  return (
    <>
      {data.map((row) => (
        <tr key={row.id}>
          <td>{row.name}</td>
          <td>{row.value}</td>
        </tr>
      ))}
    </>
  );
});

function Dashboard({ data }) {
  return (
    <div>
      <h1>Отчёт</h1>
      <table>
        <tbody>
          <TableRows data={data} />
        </tbody>
      </table>
    </div>
  );
}
```

### Когда useMemo бесполезен или вреден

Как и в случае с `React.memo`, `useMemo` не всегда приводит к улучшению производительности. В некоторых случаях его использование может даже ухудшить производительность.

- **Если вычисление лёгкое**. Например, `sum = a + b` — не нужно мемоизировать.
- **Если зависимости часто меняются**. Тогда результат всё равно пересчитывается каждый раз — мемоизация не даёт выгоды.
- **Если вы неправильно укажете зависимости**. _Например_, забудете указать `searchTerm` — получите баг: фильтрация не обновится при новом запросе.
- **Если код стал хуже читаем**. Иногда `useMemo` только путает, особенно если используется ради «чистоты» без профита.

## Вывод: когда мемоизация полезна, а когда вредна

Оптимизация — это хорошо, но применять её нужно осознанно. Новичкам может показаться: «_Отлично! Теперь всё нужно оборачивать в React.memo, все функции — в `useCallback`, а все значения — в useMemo_». На практике такой подход чаще всего ведёт к усложнению кода, не давая ощутимой выгоды, а иногда даже ухудшает производительность.

Давайте обозначим, когда действительно стоит использовать `React.memo`, `useCallback` и `useMemo`, а когда лучше обойтись без них.

- **Большие списки или таблицы, где обновляется только часть элементов**. _Пример_: таблица из 100 строк, где изменяется только одна — без оптимизации перерисуются все строки, с React.memo — только нужная.
- **Тяжёлые компоненты** с вложенными структурами, сложной версткой или расчётами внутри рендера. При частых рендерах мемоизация может существенно сократить нагрузку на интерфейс.
- **Лаги при взаимодействии**, например, при вводе текста — если каждое нажатие вызывает тормоза из-за глобального ререндера. Это сигнал, что пора оптимизировать.

**Когда оптимизация не нужна или вредна?**:

- **Мелкие или часто изменяющиеся компоненты**. Оборачивать их в `React.memo` не имеет смысла — прирост производительности будет нулевым или даже отрицательным.
- **Компоненты, которые всегда получают разные пропсы**. _Например_, генерируемые данные или случайные значения — memo не сможет ничего "спасти".
- Если вы точно знаете, что компонент всегда получает разные пропсы, `React.memo` опять же бесполезен.
- `useCallback` не стоит применять ко всем функциям подряд. Если функция не передаётся куда-то вниз, а используется только внутри компонента, мемоизировать её ни к чему. Это только усложнит код.
- **Чрезмерная оптимизация делает код тяжело читаемым**. Спустя время даже автор кода может не понять, зачем где-то применён `memo`, а где — `useMemo`, и как это всё взаимодействует с состоянием.

**Главное правило: оптимизируй там, где есть проблема**

Прежде чем оборачивать что-либо в мемоизацию, проверь, есть ли вообще производственная необходимость. Пользуйтесь профилировщиком в React DevTools Profiler [^4] — он покажет, какие компоненты рендерятся лишний раз и сколько это занимает времени.

> [!NOTE]
> Всё работает без лагов — не трогай. Начинает тормозить — профилируй и оптимизируй только то, что действительно мешает.

Разработчики React сами советуют: «сначала напишите понятный, работающий код — а уже потом оптимизируйте конкретные "узкие места" при необходимости».

В этом смысле оптимизация — как приправа: в меру — усиливает вкус, в избытке — портит всё блюдо.

[^1]: HOC — это функция, которая принимает компонент и возвращает новый компонент с изменённым поведением.
[^2]: _Optimizing React Performance By Preventing Unnecessary Re-renders_. DebugBear [online resource]. Available at: https://www.debugbear.com/blog/react-rerenders
[^3]: _Component with React.Memo - custom arePropsEqual_. codesandbox.io [online resource]. Available at: https://codesandbox.io/p/sandbox/component-with-react-memo-custom-arepropsequal-rbz80i
[^4]: _React DevTools Profiler_. chrome extension [online resource]. Available at: https://chromewebstore.google.com/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi
[^5]: _memo_. react.dev [online resource]. Available at: https://react.dev/reference/react/memo
[^6]: _React.useCallback_. react.dev [online resource]. Available at: https://react.dev/reference/react/useCallback
[^7]: _React.useMemo_. react.dev [online resource]. Available at: https://react.dev/reference/react/useMemo
