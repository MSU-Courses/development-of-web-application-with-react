# Производительность React-приложений

После изучения основных концепций React для создания простых приложений, важно понимать, как оптимизировать производительность ваших приложений. В этом разделе мы рассмотрим несколько методов и инструментов, которые помогут вам улучшить производительность ваших React-приложений.

## Почему важна производительность?

Прежде чем перейти к теме, вспомните: было ли такое, что при нажатии на кнопку вы ждали несколько секунд или даже минут? А бывало, что вы не могли прокрутить страницу вниз, потому что она подвисала? Или, может, вы ждали, пока загрузится страница, а она так и не открылась? Подобные ситуации вызывают раздражение и желание просто веб-приложение. Именно поэтому производительность веб-приложения — это не просто удобство, а ключевой элемент пользовательского опыта.

Когда мы говорим о производительности, имеем в виду, насколько быстро и плавно работает интерфейс. Пользователь ожидает, что нажатия на кнопки срабатывают сразу, списки не тормозят при прокрутке, а текст можно вводить без задержек.

В случае с React-приложением **производительность — это то, как эффективно React обновляет интерфейс при изменении данных**. Если приложение делает лишние действия, например, перерисовывает компоненты без нужды, оно начинает «тормозить» и теряет отзывчивость. В результате интерфейс может лагать, долго реагировать на действия или даже временно зависать. Именно поэтому важно оптимизировать производительность: чтобы приложение оставалось быстрым и приятным в использовании, даже если оно сложное и работает с большим объёмом данных.

Важно понять: React сам по себе достаточно эффективен, и несколько лишних перерисовок, как правило, незаметны. Но если обновления происходят слишком часто или затрагивают "тяжелые" компоненты, это может привести к заметным задержкам и ухудшению быстродействия.

В этой главе мы освежим в памяти, как работает механизм рендеринга в React, разберёмся, почему возникают лишние перерисовки и что с ними делать. Вы познакомитесь с инструментами оптимизации — такими как `React.memo`, `useCallback`, `useMemo` — и узнаете, когда их стоит использовать, а когда они только усложняют код без пользы. Мы также рассмотрим более продвинутый хук `useTransition`, который помогает управлять приоритетами обновлений, и обсудим, как производительность связана с рефакторингом и архитектурой компонентов.

## Как работает механизм повторного рендеринга в React

Прежде чем переходить к оптимизации, важно понять, как именно React повторно рендерит компоненты (_re-render_). Основы этого механизма уже рассматривались в предыдущих главах, но сейчас освежим ключевые моменты и немного углубимся в детали.

Проще говоря, _каждый рендер начинается с изменения состояния или пропсов_. Когда вызывается сеттер из `useState` или компонент получает новые пропсы от родителя, React понимает, что компонент необходимо обновить, и повторно вызывает его функцию.

Следует помнить: при повторном рендеринге компонента по умолчанию также рендерятся и все его дочерние компоненты — если не предприняты меры по их оптимизации[^1]. Это поведение по умолчанию: ререндеринг «спускается» по дереву компонентов. _Например_, если компонент Parent содержит три дочерних компонента Child, то изменение состояния в Parent вызовет его повторный рендеринг, и каждый Child также будет заново отрисован, даже если их пропсы остались без изменений.

Однако не каждое изменение в приложении вызывает рендеринг. React выделяет несколько ключевых причин, по которым компонент может быть повторно отрисован:

- **Изменение собственного состояния компонента**. _Например_, вызов `setCount(newValue)` внутри компонента приведёт к его повторному рендерингу с новым значением состояни
- **Рендеринг родительского компонента**. Если родитель перерисовывается, React по умолчанию также перерисует всех его потомков.
- **Изменение контекста (Context)**. Если компонент подписан на Context и значение контекста изменилось, он также будет повторно отрисован (_Подробнее контекст будет рассмотрен в следующей главе_).
- **Другие причины**. _Например_, использование `useReducer` или получение новых данных через `useSubscription` может привести к ререндеру (_Данные хуки будут рассмотрены в следующих главах_).

Существует распространённое упрощение: «_ререндер происходит при изменении пропсов_». Строго говоря, изменение пропсов само по себе не инициирует ререндер. React запускает рендер только при наступлении одной из причин, описанных выше. Однако на практике пропсы часто меняются как раз потому, что родительский компонент был повторно отрисован, например, из-за изменения своего состояния.

Поэтому можно упростить правило следующим образом: компонент повторно рендерится, когда изменяется его собственное состояние или когда его родитель рендерится заново и передаёт новые пропсы.

```
[setState в родителе] → [рендер родителя] → [рендер потомка]
```

### Аналогия из жизни: повторный звонок всем друзьям

Представьте, что у вас есть группа друзей (компонентов), с которыми вы созваниваетесь, чтобы быть в курсе их дел (_то есть рендерите их, чтобы обновить интерфейс_). У каждого — свои данные. Если у кого-то что-то изменилось, вы звоните именно ему и уточняете информацию.

Но React работает немного иначе: если происходит важное изменение — например, вы сменили номер телефона (аналог изменения состояния родителя), — вы обзваниваете всех друзей, даже если у большинства уже записан правильный номер. Они вежливо ответят: «Спасибо, у нас всё актуально», — но звонок уже произошёл, и ресурсы на него (то есть на рендеринг) были потрачены.

В идеале, хотелось бы звонить только тем, у кого действительно что-то поменялось. В следующих разделах мы разберём, как React помогает реализовать такой подход.

## Почему происходят ненужные перерисовки?

**Ненужные (лишние) перерисовки** — это повторные рендеры компонентов, которые не приводят к видимым изменениям интерфейса. Например, на экране отображается текст, и при повторном рендере он остаётся прежним. Такие ситуации чаще всего вызваны неэффективной архитектурой или незаметными ошибками в коде.

**Почему так происходит?** Все причины связаны с тем, как работает механизм повторного рендеринга, о котором мы говорили ранее. Вот основные из них:

- **Родительский компонент изменил состояние, не затрагивающее некоторых потомков**. Но поскольку родитель перерисовывается, вместе с ним рендерятся и все его дочерние компоненты.
  - _Пример_: у вас компонент страницы с шапкой, списком товаров и подвалом. Изменение состояния в списке товаров (_например_, применён фильтр) приведёт к рендеру всей страницы, включая шапку и подвал, даже если они не изменились.
- **Пропсы-ссылки создаются заново при каждом рендере**. _В JavaScript объекты и функции – это ссылочные типы_. Даже если их содержимое одинаковое, новая ссылка в памяти считается другим значением. Таким образом, дочерний компонент получит «новые-старые» пропсы и перерисуется, хотя содержательно пропсы не поменялись.
  - _Пример_: родитель при каждом рендере создаёт функцию и передаёт её в дочерний компонент, React считает это новыми пропсами, так как поменялась ссылка на функцию, и вызывает повторный рендер. Хотя логически данные не изменились. _Это одна из самых распространённых причин лишних перерисовок_.
- **Inline-объекты и массивы в пропсах.**. Например: <Child `style={{ color: 'blue' }}` />. При каждом рендере создаётся новый объект `style`, и компонент Child получает «новые» пропсы — даже если визуально стиль тот же. _Это причина следует из предыдущей_.

Чем больше таких ненужных ререндеров, тем выше нагрузка на браузер. Это особенно заметно на слабых устройствах или при очень обширном интерфейсе.

_Пример_: в списке из 1000 элементов каждый элемент — это отдельный компонент. При выборе одного элемента изменяется состояние родителя. Без оптимизации React вызовет функцию рендера для всех 1000 компонентов, хотя изменился только один.

### Типичный пример лишнего рендеринга

Рассмотрим простой пример без оптимизации. У нас есть два счётчика (два компонента `Counter`) и кнопка, увеличивающая значение первого счётчика:

**Пример 1**. _Пример лишнего рендеринга_

```jsx
function App() {
  const [counterA, setCounterA] = React.useState(0);
  const [counterB, setCounterB] = React.useState(0);

  return (
    <div>
      <Counter name="A" value={counterA} />
      <Counter name="B" value={counterB} />
      <button onClick={() => setCounterA(counterA + 1)}>Увеличить A</button>
    </div>
  );
}

function Counter({ name, value }) {
  console.log(`Rendering counter ${name}`);
  return (
    <div>
      {name}: {value}
    </div>
  );
}
```

**Что произойдёт, если нажать на кнопку «Увеличить A»?** Обновится состояние `counterA`, React повторно перерисует компонент `App`, и в следствии перерисует оба компонента `Counter`. В консоли появится:

```
Click button
Rendering counter A
Rendering counter B
```

Это значит, что компонент `CounterB` тоже перерисовался, хотя его значение не изменилось (по-прежнему 0). Он был отрендерен снова только потому, что родительский компонент `App` обновился и передал пропсы заново.

**Почему так случилось?** По умолчанию React не анализирует, действительно ли пропсы изменились — он просто повторно вызывает дочерние компоненты при ререндере родителя. Мы не дали компоненту `Counter` инструкций пропустить лишний рендер, поэтому React перестраховывается и обновляет всё.

В небольших приложениях это может быть незаметно, но в более сложных интерфейсах подобные ререндеры могут существенно повлиять на производительность.

## Recap: Производительность React-приложений

1. React повторно рендерит компоненты при изменении состояния, пропсов или контекста.
2. Ререндер родителя вызывает ререндер всех его потомков — даже если их пропсы не изменились.
3. Лишние ререндеры ухудшают производительность и отзывчивость интерфейса.
4. Основные причины лишних ререндеров:

   - новые объекты/функции в пропсах;
   - inline-стили и массивы;
   - изменение состояния в родителе.

5. Примеры: повторный рендер компонента, даже если данные остались прежними.
6. Инструменты оптимизации:

   - `React.memo` — мемоизация компонента;
   - `useCallback` — мемоизация функций;
   - `useMemo` — мемоизация значений;
   - `useTransition` — управление приоритетами обновлений.

7. Производительность зависит не только от инструментов, но и от архитектуры приложения.
8. React сам по себе быстр, но оптимизация важна в масштабируемых проектах.

[^1]: _Optimizing React Performance By Preventing Unnecessary Re-renders_. DebugBear [online resource]. Available at: https://www.debugbear.com/blog/react-rerenders
[^2]: _React: полное руководство по повторному рендерингу_. habr.com. [online resource]. Available at: https://habr.com/ru/companies/timeweb/articles/684718/
