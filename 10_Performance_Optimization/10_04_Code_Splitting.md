# Code Splitting в React: Разделение кода

> [!NOTE]
> Данная глава является дополнительной и не является обязательной для прохождения курса. Она предназначена для тех, кто хочет углубить свои знания в области оптимизации производительности React-приложений и изучить более продвинутые техники.

Помимо оптимизации производительности через мемоизацию и приоритизацию обновлений, React предлагает ещё один важный механизм — **разделение кода (code splitting)**. Это позволяет значительно улучшить скорость загрузки и общую производительность приложения, особенно если оно состоит из большого количества компонентов, страниц или модулей. Разделение кода основано на простой идее: загружать только те части приложения, которые действительно нужны в текущий момент, а не весь код сразу. Это особенно актуально для масштабных приложений, где не все функции используются сразу после запуска.

При разработке React-приложений важно следить за размером итогового JavaScript-бандла. Если всё приложение собирается в один файл, он может получиться слишком большим — и это замедлит загрузку страницы, особенно на мобильных устройствах и медленных сетях.

Здесь на помощь приходит Code Splitting — техника, поддерживаемая сборщиками вроде Webpack и Rollup, позволяющая разбить приложение на небольшие части (чанки), которые будут загружаться по мере необходимости. Хотя общий объём кода приложения при этом не уменьшается, мы откладываем загрузку тех участков, которые могут вообще не понадобиться пользователю. В результате значительно снижается объём кода, загружаемого при старте, и ускоряется отображение первого экрана.

Основные инструменты для реализации ленивой загрузки в React:

- Функция `React.lazy()` — позволяет загружать компоненты динамически;
- Компонент `<Suspense>` — отображает заглушку во время загрузки;
- Возможности React Router для ленивой загрузки маршрутов;
- Tree Shaking — автоматическое удаление неиспользуемого кода при сборке;
- Реэкспорт модулей — помогает структурировать код, но требует аккуратности при использовании с Tree Shaking.

В этой главе мы подробно разберём, как применяются эти инструменты на практике, на что стоит обратить внимание при их использовании, и как избежать типичных ошибок. Также мы рассмотрим, как правильно организовать структуру проекта с учётом разделения кода, и приведём практические рекомендации и таблицу-сравнение подходов к ленивой загрузке.

## React.lazy и Suspense

`React.lazy()` — это встроенная функция React, которая позволяет загружать компоненты динамически по мере необходимости. Она принимает функцию, возвращающую промис (обычно — `import()`), и возвращает React-компонент, который будет автоматически загружен при первом рендере. Проще говоря, React.lazy превращает ленивый импорт в обычный React-компонент.

`<Suspense>` — это специальный компонент-обёртка, необходимый для использования React.lazy. Пока ленивый компонент ещё не загружен (промис не выполнен), `Suspense` отображает запасной контент, указанный в свойстве `fallback` [^1].

**Обычно это**:

- индикатор загрузки (`<Spinner />`);
- сообщение "Загрузка...";
- Skeleton UI — предварительный каркас интерфейса, имитирующий финальный вид.

`Suspense` позволяет плавно обработать задержку при загрузке, чтобы пользователь не столкнулся с пустым экраном.

Таким образом, `React.lazy()` + `<Suspense>` = простой и нативный способ реализовать ленивую загрузку компонентов в React.

> [!IMPORTANT]
> Функция `React.lazy` работает только с экспортом по умолчанию (default export). Модуль, который вы загружаете таким способом, должен экспортировать нужный компонент как `export default​`.

### Пример: ленивое загрузка отдельного компонента

Рассмотрим практический случай. Допустим, у нас есть компонент `HeavyChart`, который использует крупную библиотеку для построения графиков. Этот компонент не нужен сразу при загрузке приложения — он отображается только по запросу пользователя, _например_, после нажатия кнопки «Показать график».

В такой ситуации особенно разумно загрузить компонент лениво, чтобы не включать его код в стартовый бандл.

**Пример 1**. _Ленивая загрузка компонента HeavyChart_

_Файл_ `HeavyChart.jsx`

```jsx
// Импортирует большую библиотеку (условно)
import { ChartLibrary } from 'big-chart-lib';

export default function HeavyChart({ data }) {
  return <ChartLibrary data={data} />;
}
```

_Файл_ `Dashboard.jsx`

```jsx
import React, { useState, Suspense, lazy } from 'react';

const HeavyChart = lazy(() => import('./HeavyChart')); // ленивый импорт

function Dashboard() {
  const [showChart, setShowChart] = useState(false);

  const handleClick = () => {
    setShowChart(true);
  };

  return (
    <div>
      <h1>Панель управления</h1>
      <button onClick={handleClick}>Показать график</button>

      <Suspense fallback={<div>Загрузка графика...</div>}>
        {showChart && <HeavyChart data={someData} />}
      </Suspense>
    </div>
  );
}
```

Как это работает?

- Компонент `HeavyChart` не включается в основной бандл при загрузке страницы;
- Код этого компонента загружается только после нажатия на кнопку;
- Пока компонент ещё не загружен, `<Suspense>` показывает запасной контент (`Загрузка графика...`);
- Как только модуль подгружается — React автоматически отрисовывает `HeavyChart` с переданными данными.

Компонент `HeavyChart` будет загружен только тогда, когда состояние `showChart` станет `true`, то есть после нажатия кнопки. До этого момента код из файла `HeavyChart.jsx` вообще не загружается в браузер и не попадает в стартовый бандл, так как он не используется. Пока модуль с графиком загружается (бандл _"летит по сети"_), компонент `<Suspense>` отображает запасной контент — в данном случае текст «_Загрузка графика.._.». Как только загрузка завершится, React автоматически отрисует реальный компонент `<HeavyChart>` с переданными данными.

Ленивый компонент можно предзагрузить заранее, если есть предположение, что он скоро понадобится. Это позволяет сократить задержку между действием пользователя и отображением компонента. _Например_, можно вызвать `import('./HeavyChart')` в обработчике события — за мгновение до того, как компонент действительно понадобится (например, при наведении на кнопку). Также можно использовать `useEffect`, чтобы загрузить компонент "втихую" после загрузки страницы, не отображая его сразу. В таком случае модуль будет сохранён в кэше, и при необходимости отобразится моментально:

**Пример 2**. _Предварительная загрузка компонента HeavyChart_

```jsx
useEffect(() => {
  // Прогреваем компонент заранее
  import('./HeavyChart');
}, []);
```

> [!TIP]
> Это особенно полезно, если компонент "тяжёлый", а вы хотите сохранить ощущение мгновенного отклика при его открытии.

**Схема 1**. _Ленивая загрузка компонентов в React_

<img src="https://imgur.com/STvyANY.png" alt="Ленивая загрузка компонентов в React" width="600" />

### Ленивая загрузка маршрутов (маршрутизация)

Маршруты (страницы) приложения — один из самых очевидных и эффективных кандидатов для применения code splitting. Пользователи привыкли, что при переходе на новую страницу возможна кратковременная загрузка, поэтому задержка в 200–500 мс обычно воспринимается естественно. Это позволяет загружать код каждой страницы только при переходе к ней, существенно снижая объём стартового бандла.

#### Как реализовать ленивую маршрутизацию в React

С использованием `React Router v6+` и `React.lazy` ленивые маршруты реализуются очень просто:

- Страницы определяются через `lazy()` — это отложит их загрузку;
- Все маршруты оборачиваются в `<Suspense>`, чтобы обработать момент загрузки;
- В `fallback` передаётся, например, **спиннер**, **скелетон** или текст `Загрузка....`

**Пример 3**. _Ленивая загрузка маршрутов с React Router_

```jsx
import React, { Suspense, lazy } from 'react';
import { BrowserRouter as Router, Routes, Route, Link } from 'react-router-dom';

const HomePage = lazy(() => import('./pages/HomePage'));
const AboutPage = lazy(() => import('./pages/AboutPage'));

function App() {
  return (
    <Router>
      <nav>
        <Link to="/">Главная</Link>
        <Link to="/about">О сайте</Link>
      </nav>

      <Suspense fallback={<div>Загрузка страницы...</div>}>
        <Routes>
          <Route path="/" element={<HomePage />} />
          <Route path="/about" element={<AboutPage />} />
        </Routes>
      </Suspense>
    </Router>
  );
}
```

В данном примере:

- При первом открытии приложения в браузер попадёт только код `App` и главной страницы (`HomePage`);
- Код страницы `AboutPage` будет вынесен в отдельный `chunk` сборщиком (например, `AboutPage.chunk.js`);
- Этот chunk будет загружен только в момент перехода на `/about`;
- Пока файл грузится — React отобразит `fallback` из `<Suspense>`.

> [!NOTE]
> Не забудьте предусмотреть разные fallback'и для разных страниц, если они существенно различаются по объёму или структуре.

## Реэкспорт модулей и организация импорта

В больших React-проектах с десятками компонентов, утилит и модулей часто используется приём, известный как **barrel-файлы** (от англ. barrel — «бочка»). Это специальный файл, который реэкспортирует множество элементов из разных модулей, предоставляя единый интерфейс для импорта [^3]​.

Вместо того чтобы импортировать каждый компонент напрямую из своей папки, мы создаём один файл (обычно `index.js`), который экспортирует всё, что нам нужно. Это делает импорты короче, централизованными и менее зависимыми от внутренней структуры проекта.

**Пример 4**. _Структура без barrel-файлов_

```jsx
import Button from './components/Button';
import Header from './components/Header';
import Footer from './components/Footer';
```

**Пример 5**. _Структура с barrel-файлом_

```jsx
// components/index.js
// barrel-файл, который реэкспортирует все компоненты из папки
export * from './Button';
export * from './Header';
export * from './Footer';
// ... и т.д. реэкспортируем всё из подмодулей
```

Теперь вместо того чтобы импортировать каждый компонент из своего файла, можно писать:

```jsx
import { Button, Header, Footer } from './components';
```

**Преимущества barrel-файлов**:

- **Упрощают импорты**. Меньше повторяющихся путей;
- **Скрывают структуру проекта**. Внешнему коду не важно, где физически лежат компоненты;
- **Удобны для переэкспорта библиотек**. Один вход вместо десятков путей;
- **Повышают читаемость**. Особенно в больших файлах с множеством импортов.

Многие библиотеки (например, `@mui/material`, `date-fns`, `lodash-es`) предоставляют централизованные точки входа по этому же принципу, чтобы упростить жизнь разработчикам.

У такого удобства есть обратная сторона. Когда вы импортируете что-то из barrel-файла, на этапе сборки и выполнения может быть загружен весь файл и все его зависимости. _Например_: если barrel-файл реэкспортирует тысячу компонентов, а вы используете только один, то весь остальной код тоже может попасть в финальный бандл [^4], особенно если механизм Tree Shaking (_будет рассмотрен ниже_) не справляется с удалением неиспользуемого. Это означает: вы можете "заплатить"
_загрузкой_ и _хранением кода, который никогда не будет использован в вашем приложении_.

### Советы по реэкспорту

1. Явно перечисляйте экспортируемое вместо `export *`. Если вам нужен barrel, лучше писать:

   ```jsx
   // Плохо
   export * from './Button';
   export * from './Header';

   // Хорошо

   // Если export const Component = () => {...}
   export { Button } from './Button';
   export { Header } from './Header';

   // Если export default Component
   export { default as Button } from './Button';
   export { default as Header } from './Header';
   ```

2. **Избегайте глубоких цепочек реэкспорта**. Если `index.js` реэкспортирует из файла `A.js`, а тот, в свою очередь, реэкспортирует из `B.js`, и т.д., увеличивается риск, что что-то пойдёт не так и неиспользованный код останется. Такие сложности затрудняют анализ зависимостей.

## Что такое Tree Shaking?

**Tree Shaking** — это техника оптимизации сборки, при которой из финального бандла устраняется неиспользуемый код.

_Название происходит от метафоры_: как будто сборщик стряхивает мёртвые ветки с дерева зависимостей, оставляя только то, что действительно используется.

Сборщик (_например_, Webpack, Rollup или Vite) анализирует все модули проекта и удаляет экспортированные сущности, которые нигде не импортируются и не используются.
Благодаря tree shaking, в продакшн не попадут компоненты, функции или утилиты, которые были написаны, но так и не были применены в проекте.

Для эффективного tree shaking требуется, чтобы модули были написаны в виде ES6-модулей с явными `import/export`. Статическая структура ES-модулей позволяет инструментам однозначно увидеть зависимости и безопасно удалить лишнее [^5]. Если же модули используют динамические формы импорта или CommonJS (require), то сборщик не всегда сможет определить, какой код точно не выполняется.

### Факторы, мешающие Tree Shaking и увеличивающие размер бандла

#### Сайд-эффекты в коде

Если модуль при импорте выполняет какой-либо код — например:

- пишет в консоль (`console.log`);
- модифицирует глобальные объекты;
- вызывает побочные эффекты вне экспортируемых функций;

…то сборщик не может быть уверен, что этот код можно удалить, даже если вы не используете его экспорт. В результате такой модуль останется в финальном бандле.

**Решение**:

1. Выносите побочные действия в отдельные модули;
2. Помечайте чистые модули как безопасные для удаления:

   ```json
   // В package.json:
   {
     "sideEffects": false
   }
   ```

   Это говорит сборщику, что в этом модуле нет побочных эффектов, и он может смело удалять неиспользуемый код.

#### Wildcard-экспорты и динамические обращения

Экспорты вида `export * from 'X.js';` или динамическая сборка экспортов в объект (например, `export const lib = { Foo, Bar }`) могут затруднить анализ зависимостей.

> [!NOTE]
> Современные сборщики уже умеют частично обрабатывать `export *`, но такой код всегда менее предсказуем для tree shaking, чем точечные экспорты.

#### Импорт через barrel-файлы

Импорт через общие `index.js` (barrel-файлы), в которых собраны десятки или сотни экспортов, может привести к тому, что в бандл попадёт весь связанный код, даже если реально используется только один компонент.

Это особенно вероятно, если:

- используется CommonJS (`require` вместо `import/export`);
- экспорт реализован через `export *`;
- сборщик не может точно вычислить, что именно требуется.

**Решение**:

В критичных по весу участках (например, в лениво загружаемых компонентах) используйте прямой импорт из подмодуля:

```jsx
// Вместо:
import { Chart } from './components';

// Лучше:

// Если export const Component = () => {...}
import { Chart } from './components/Chart';

// Если export default Component
import Chart from './components/Chart';
```

## Вывод и практические рекомендации

Завершая главу о Code Splitting и Tree Shaking, приведём краткий список рекомендаций, которые помогут сократить размер бандла, ускорить загрузку и улучшить производительность React-приложения:

### Разделяйте код по маршрутам

Начинайте оптимизацию с ленивой загрузки страниц.

Каждый маршрут (`/home`, `/about`, `/profile` и т.д.) — это отличная точка для разделения кода.

Загружайте код страницы только при переходе на неё с помощью `React.lazy` и `Suspense`.

> [!TIP]
> Это даёт максимальный выигрыш при минимальных усилиях и особенно важно для SPA-приложений.

### Лениво подключайте тяжёлые компоненты

Если на странице есть модули, которые не нужны сразу — _например_, графики, редакторы, таблицы, модалки — загружайте их по событию: клику, скроллу или смене вкладки.

Пользователь получит быстрый отклик интерфейса, а нужный функционал подгрузится в фоне без блокировки UI.

### Организуйте импорты с умом

Barrel-файлы (`index.js`) — это удобно, но с ними нужно быть аккуратным:

- Избегайте слепых `export *` — используйте только то, что нужно;
- Для критичных участков кода импортируйте модули напрямую, минуя общие входы, особенно в больших библиотеках.

### Пишите чистые и изолированные модули

- Избегайте побочных эффектов (логов, глобальных изменений, регистрации чего-либо при `import`);
- Стройте модули вокруг чистых экспортов (функций, компонентов);
- Если побочные эффекты всё же есть — помечайте модули как `sideEffects` в `package.json`, чтобы сборщик понимал, что их трогать нельзя.

### Используйте современные инструменты

Используйте актуальные версии сборщиков, таких как Vite или Webpack. Они постоянно улучшают алгоритмы tree shaking и код-сплиттинга.

- `Vite` (на базе Rollup) изначально нацелен на агрессивное удаление лишнего кода;
- `Webpack` (в production-режиме) тоже поддерживает tree shaking, но может требовать ручной настройки;
- Обновляйте сборщики до актуальных версий — многие улучшения работают «из коробки».

### Итог

**Code Splitting** позволяет загружать только нужное — когда это нужно.

**Tree Shaking** — удаляет мёртвый код, экономя мегабайты и миллисекунды.

Применяя их в связке, вы добиваетесь быстрого запуска, мгновенного отклика и масштабируемого проекта без избыточной нагрузки.

[^1]: _Разделение кода с помощью React.lazy и Suspense_. web.dev [online resource]. Available at: https://web.dev/articles/code-splitting-suspense
[^2]: _Optimizing React Apps with Code Splitting and Lazy Loading_. medium [online resource]. Available at: https://medium.com/@ignatovich.dm/optimizing-react-apps-with-code-splitting-and-lazy-loading-e8c8791006e3
[^3]: _Burn the Barrel!_. medium.com [online resource]. Available at: https://uglow.medium.com/burn-the-barrel-c282578f21b6
[^4]: _What's the problem with barrel files?_. vercel.com [online resource]. Available at: https://vercel.com/blog/how-we-optimized-package-imports-in-next-js#what's-the-problem-with-barrel-files?
[^5]: _Boosting React.js Performance with Tree Shaking_. readmedium [online resource]. Available at: https://readmedium.com/boosting-react-js-performance-with-tree-shaking-ee77261d0c95
