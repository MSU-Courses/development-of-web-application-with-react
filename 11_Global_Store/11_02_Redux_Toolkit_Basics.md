# Использование Redux Toolkit в React

В предыдущей главе мы рассмотрели один из ключевых инструментов для работы с глобальным состоянием — контекст и хук `useContext`. Этот подход отлично подходит для простых случаев, когда нужно передать данные между несколькими компонентами без глубокой вложенности или сложной логики управления.

Однако по мере роста приложения `useContext` начинает проявлять свои ограничения:

- требуется создавать несколько отдельных контекстов;
- сложно управлять взаимосвязанными состояниями;
- становится труднее масштабировать и тестировать код.

В таких ситуациях разумнее использовать специализированные библиотеки управления состоянием. Одной из самых популярных и широко применяемых в экосистеме React является Redux, а именно его современная, рекомендуемая версия — Redux Toolkit (RTK)[^1].

Redux Toolkit предлагает более удобный и декларативный способ описания глобального состояния, избавляя разработчика от необходимости вручную писать редьюсеры, экшены и настраивать хранилище. Он также включает встроенную поддержку асинхронных операций и отлично сочетается с TypeScript.

## Кратко о Redux и причина появления Redux Toolkit

В данной главе намеренно разделены понятия _Redux_ и _Redux Toolkit (RTK)_, поскольку они представляют собой разные уровни абстракции одной и той же технологии.

**Redux** — это одна из самых известных библиотек для управления глобальным состоянием в приложениях. Она появилась ещё до появления хуков и Context API в React и быстро стала стандартом де-факто. Основная идея Redux — предсказуемость и управляемость состояния: всё состояние приложения хранится централизованно в одном хранилище (store), изменяется строго через редьюсеры (чистые функции) и действия (actions), что обеспечивает контроль над потоком данных.

Однако классическая реализация Redux имела ряд существенных недостатков:

1. Сложная настройка хранилища.
2. Избыточный шаблонный код — даже для простого счетчика приходилось писать много кода.
3. Дополнительные зависимости.

В итоге на простую бизнес-логику уходило слишком много _“инфраструктурного”_ кода (кода, который помогал организовать структуру приложения).

Чтобы решить эти проблемы, в 2019 году был представлен **Redux Toolkit (RTK)** — официальная надстройка над Redux, разработанная командой Redux. Redux Toolkit стал рекомендуемым способом использования Redux, так как он:

- Упрощает настройку хранилища.
- Предоставляет удобный API.
- Устраняет избыточный шаблонный код.

По сути, RTK "инкапсулирует" лучшие практики Redux и предлагает простой, лаконичный синтаксис.

Мы не будем подробно изучать классический Redux, а сразу перейдём к Redux Toolkit, поскольку он является современным стандартом и рекомендуется к использованию.

## Основные концепции Redux Toolkit

Как было подмечено ранее, Redux Toolkit не заменяет, а упрощает работу с классическим Redux, сохраняя его фундаментальные принципы, но избавляя от избыточного кода и сложной настройки. Ниже рассмотрим ключевые концепции и API, с которыми работает Redux Toolkit:

- **Store** (хранилище) — централизованное хранилище всего состояния приложения. Компоненты получают доступ к данным через это хранилище и могут инициировать изменения состояния.
- **Slice** (срез состояния) – концепция, представляющая обособленную часть глобального состояния вместе с логикой его обновления. Можно сказать, что это некоторая часть хранилища, которая отвечает за определённую функциональность приложения. _Например_, срез todos для списка задач, auth для авторизации и т.д. Каждый slice обычно создаётся через `createSlice`.
- **Reducer** – чистая функция, обновляющая состояние на основе полученного действия (action). Де-факту, это чистая функция, которая принимает текущее состояние и действие, и обновляет состояние в зависимости от типа действия. _Например_, если действие - добавление задачи, то редьюсер обновляет состояние, добавляя новую задачу в массив задач.
- **configureStore** – функция для создания хранилища Redux.
- **Middleware** – промежуточные обработчики действий. Позволяют логировать действия, обрабатывать побочные эффекты, выполнять проверки и т.д. В RTK уже встроены базовые middleware.
- **Redux DevTools** [^2] – мощное расширение для браузера, позволяющее отслеживать изменения состояния, откатывать действия, проводить отладку и визуализировать весь поток данных. В Redux Toolkit поддержка DevTools включена по умолчанию — дополнительных шагов по подключению не требуется.

Для подключения Redux-хранилища к React-приложению необходимо использовать компонент `<Provider store={store}>` из библиотеки `react-redux`, оборачивая в него корневой компонент приложения. Это делает состояние доступным во всех дочерних компонентах.

## Пример: создание состояния с Redux Toolkit

Рассмотрим простой пример, как с помощью Redux Toolkit создать глобальное состояние и использовать его в компоненте. Реализуем пример из главы `11_01` с использованием контекста, но теперь с использованием Redux Toolkit. В компонента `App->ProfilePage->ProfileForm->TextInput` меняем имя пользователя, а в компоненте `App->Header` изменяем имя пользователя.

### Шаг 1: Установка Redux Toolkit

Для начала необходимо установить библиотеки `Redux Toolkit` и `React-Redux`. Библиотека `React-Redux` предоставляет компоненты и хуки для интеграции Redux с React-приложениями.

```bash
npm install @reduxjs/toolkit react-redux
```

### Шаг 2: Создание и подключение Redux-хранилища

Рекомендуется создать отдельную директорию для файлов, связанных с Redux. Обычно это папка `src/redux` или `src/store`, в которой будут располагаться хранилище (`store`), срезы состояния (`slices`) и дополнительные настройки, если потребуется.

**Пример 1**. _Создание Redux-хранилища_

Файл `src/redux/store.js`:

```javascript
import { configureStore } from "@reduxjs/toolkit";

const store = configureStore({
  reducer: {},
});

export default store;
```

Функция `configureStore` предоставляет оптимизированную конфигурацию по умолчанию.

Чтобы сделать Redux-хранилище доступным во всех компонентах приложения, необходимо обернуть корневой компонент в провайдер `Provider` из библиотеки `react-redux`, передав ему объект `store` (хранилище, которое вы создали в Примере 1).

**Пример 2**. _Подключение Redux-хранилища к приложению_

Файл `src/index.js`:

```jsx
import React from "react";
import ReactDOM from "react-dom/client";
import App from "./App";

// Импортируем Redux-хранилище и провайдер
import { Provider } from "react-redux";
import store from "./redux/store";

const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(
  <Provider store={store}>
    <App />
  </Provider>
);
```

Теперь Redux-хранилище будет доступно во всём дереве компонентов, начиная с корневого `<App />`.

### Шаг 3: Создание среза состояния

После настройки хранилища следующим шагом является его разделение на логические части — срезы состояния (slices), каждая из которых отвечает за определённую функциональность в приложении.

Каждый срез включает в себя:

- **начальное состояние**;
- **редьюсеры** — функции, которые описывают, как должно изменяться состояние;
- **действия** (actions) — функции, с помощью которых запускаются редьюсеры.

Рекомендуется создать отдельную директорию для срезов, например `src/redux/slices`, где будут храниться все логически независимые участки состояния.

Рассмотрим пример среза состояния, отвечающего за данные пользователя.

**Пример 3**. _Создание среза состояния_

Файл `src/redux/slices/userSlice.js`:

```javascript
import { createSlice } from "@reduxjs/toolkit";

// Начальное состояние
const initialState = {
  name: "John Doe",
};

// Создание среза состояния
const userSlice = createSlice({
  name: "user",
  initialState,
  reducers: {
    setName(state, action) {
      state.name = action.payload;
    },
    resetName(state) {
      state.name = initialState.name;
    },
    capitalizeName(state) {
      state.name = state.name.toUpperCase();
    },
  },
});

// Экспорт действий и редьюсера
export const { setName, resetName, capitalizeName } = userSlice.actions;
export default userSlice.reducer;
```

В данном примере:

- `initialState` задаёт начальное значение состояния;
- Действие `setName` обновляет имя пользователя в состоянии. Оно обрабатывается соответствующим редьюсером и принимает два параметра:
  - `state` (_обязательный параметр_) — текущее состояние среза;
  - `action` (_необязательный параметр_) — объект действия, содержащий тип действия и полезную нагрузку (`payload`), то есть данные, передаваемые для обновления (_например_, новое имя пользователя).
- Действие `resetName` сбрасывает имя пользователя к значению, заданному в initialState.
- Действие `capitalizeName` преобразует имя пользователя в верхний регистр.

#### Разница между Reducer и Action

На первый взгляд различие между понятиями `action` и reducer `может` показаться запутанным: с одной стороны, мы описываем функцию-редьюсер, а с другой — используем одноимённую функцию как действие, что создаёт ощущение, будто это одно и то же.

На самом деле всё просто:

- `reducer` — это функция, которая реагирует на действие (`action`) и обновляет состояние.
- `action` — это объект, который описывает, что произошло (_например_, "пользователь ввёл имя").

_В примере выше_:

- **Редьюсеры** — это функции, определённые внутри объекта `reducers` (`setName`, `resetName`, `capitalizeName`). Они принимают текущее состояние и объект действия (action), после чего обновляют состояние в зависимости от типа действия. Эти функции не вызываются напрямую — они автоматически срабатывают в ответ на соответствующие действия, переданные в хранилище.
- Действия (action creators) — это функции, которые вызываются в компонентах и формируют объект действия. Redux Toolkit автоматически создаёт такие функции на основе имён редьюсеров. Например, строка: `export const { setName, resetName, capitalizeName } = userSlice.actions;` создает три функции-действия. Вызов `setName("Alice")` вернёт следующий объект: `{ type: "user/setName", payload: "Alice" }`. Можно заметить, что действия называются по типу `<имя среза>/<имя действия>`, что позволяет избежать конфликтов между разными срезами.
- Таким образом, существует два разных "варианта" setName:
  - `setName` внутри `reducers` — это редьюсер, который описывает, как обновлять состояние;
  - `setName`, экспортируемый из `userSlice.actions`, — это действие, которое используется для запуска этого редьюсера.

> [!TIP]
> Хотя названия совпадают, функции выполняют разные роли: одна описывает, что делать, другая — как это сделать.

### Шаг 4: Подключение среза состояния к хранилищу

После создания среза необходимо подключить его срез к Redux-хранилищу, чтобы он стал частью глобального состояния приложения.

**Пример 4**. _Подключение среза состояния к хранилищу_

Файл `src/redux/store.js`:

```javascript
import { configureStore } from "@reduxjs/toolkit";
import userReducer from "./slices/userSlice";

export const store = configureStore({
  reducer: {
    user: userReducer, // Подключаем срез к хранилищу
  },
});

export default store;
```

Теперь срез `userSlice` интегрирован в хранилище, и вы можете использовать данные пользователя и соответствующие действия (`setName`, `resetName`, `capitalizeName`) в React-компонентах с помощью соответствующих хуков.

Чтобы обратиться к данным из состояния, необходимо использовать `state.user`, где `user` — это имя среза, заданное при конфигурации хранилища: `user: userReducer`. Если бы в хранилище был добавлен ещё один срез, например `todos`, то к его данным можно было бы обратиться через `state.todos`.

### Шаг 5: Использование состояния в компонентах

Теперь, когда Redux-хранилище и срез состояния настроены, можно использовать их в компонентах приложения. Redux Toolkit предоставляет несколько хуков для работы с состоянием и действиями.

#### Хук `useDispatch`

Хук `useDispatch` предоставляется библиотекой `react-redux` и возвращает ссылку на функцию `dispatch`, которая используется для отправки действий (`actions`) в Redux-хранилище. С помощью dispatch можно инициировать изменения состояния, передавая заранее созданное действие, _например_, `setName("Alice")`.

**Пример 5**. _Использование `useDispatch` для отправки действий_

Файл `src/components/TextInput.jsx`:

```jsx
import React, { useState } from "react";

// Импорт хука useDispatch
import { useDispatch } from "react-redux";

// Импорт действия из среза состояния
import { setName } from "../redux/slices/userSlice";

const TextInput = () => {
  const [name, setNameInput] = useState("");

  // Получаем функцию dispatch
  const dispatch = useDispatch();

  const handleChange = (e) => {
    setNameInput(e.target.value);
  };

  const handleSubmit = (e) => {
    e.preventDefault();
    // Отправляем действие для обновления имени пользователя
    dispatch(setName(name));
    setNameInput("");
  };

  return (
    <form onSubmit={handleSubmit}>
      <input type="text" value={name} onChange={handleChange} />
      <button type="submit">Изменить имя</button>
    </form>
  );
};

export default TextInput;
```

Файл `src/components/ProfilePage.jsx`:

```jsx
import React from "react";

import ProfileForm from "./ProfileForm";

import { useDispatch } from "react-redux";
import { resetName, capitalizeName } from "../redux/slices/userSlice";

const ProfilePage = () => {
  const dispatch = useDispatch();

  const handleReset = () => {
    dispatch(resetName());
  };

  const handleCapitalize = () => {
    dispatch(capitalizeName());
  };

  return (
    <div>
      <h2>Профиль</h2>
      <ProfileForm />
      <button onClick={handleReset}>Сбросить имя</button>
      <button onClick={handleCapitalize}>Заглавить имя</button>
    </div>
  );
};

export default ProfilePage;
```

`useDispatch` позволяет взаимодействовать с хранилищем Redux из компонентов React: вы можете отправлять действия, инициировать обновления состояния и тем самым реализовывать реактивную бизнес-логику.

#### Хук `useSelector`

Хук `useSelector` предоставляется библиотекой react-redux и используется для извлечения данных из Redux-хранилища. Он принимает функцию-селектор, которая получает текущее состояние (`state`) и возвращает интересующий участок данных.

Селекторы позволяют компонентам подписываться только на нужные части состояния, что помогает избежать лишних перерисовок.

**Пример 6**. _Использование `useSelector` для получения данных из состояния_

Файл `src/components/Header.jsx`:

```jsx
import React from "react";

// Импорт хука useSelector
import { useSelector } from "react-redux";

const Header = () => {
  // Получаем имя пользователя из состояния
  const name = useSelector((state) => state.user.name);

  return (
    <header>
      <h1>Добро пожаловать, {name}!</h1>
    </header>
  );
};

export default Header;
```

#### Как это работает?

Когда вы вызываете `useSelector`, компонент подписывается на изменения определённой части состояния Redux, которую возвращает селектор.

Если после вызова `dispatch` изменилось именно то значение, на которое подписан компонент через useSelector, — этот компонент будет повторно отрендерен. Если же обновление состояния не затронуло данные, которые использует селектор, компонент не будет перерисован.

Такой механизм позволяет избегать ненужных ререндеров и способствует оптимизации производительности приложения.

_Например_, если один компонент использует `state.user.name`, а другой — `state.todos.list`, то при обновлении имени пользователя (`setName`) перерисуется только первый компонент, а второй останется без изменений.

### Шаг 6: Функции-селекторы

В более сложных сценариях, когда необходимо извлечь данные из нескольких участков состояния или выполнить дополнительные вычисления, рекомендуется использовать функции-селекторы (`selectors`).

Селекторы позволяют:

- инкапсулировать логику извлечения данных;
- улучшать читаемость компонентов;
- повторно использовать один и тот же код;
- при необходимости — легко подключать мемоизацию.

**Пример 7**. _Создание функции-селектора_

Файл `src/redux/slices/userSlice.js`:

```javascript
import { createSlice } from "@reduxjs/toolkit";

//  Начальное состояние и редьюсеры — как в предыдущем примере (3)

// Функция-селектор для получения имени пользователя
export const selectUserName = (state) => state.user.name;

// Функция-селектор для получения длины имени пользователя
export const selectUserNameLength = (state) => state.user.name.length;
```

> [!NOTE]
> Селекторы получают всё состояние Redux (state) и извлекают из него нужные данные, ссылаясь на имя среза (user), указанное в configureStore. Селекторы могут быть простыми (как в примере выше) или сложными, комбинируя несколько селекторов и выполняя дополнительные вычисления.

**Пример 8**. _Использование функции-селектора_

Файл `src/components/Header.jsx`:

```jsx
import React from "react";

import { useSelector } from "react-redux";

import { selectUserName } from "../redux/slices/userSlice";

const Header = () => {
  // Используем функции-селекторы для получения данных
  const name = useSelector(selectUserName);

  return (
    <header>
      <h1>Добро пожаловать, {name}!</h1>
    </header>
  );
};

export default Header;
```

Использование селекторов способствует разделению ответственности: компоненты становятся проще, а логика извлечения данных — централизованной и переиспользуемой.

> [!TIP]
> Для мемоизации селекторов можно использовать библиотеку `reselect`, которая позволяет создавать производительные селекторы, кеширующие результаты вычислений.

### Шаг 7: Разделение логики

Хорошей практикой при работе с Redux является структурирование логики по функциональным модулям. Вместо того чтобы хранить все срезы, селекторы и асинхронные действия в одной папке, рекомендуется разбивать их по смысловым разделам приложения.

_Например_, если в приложении есть отдельные сущности — пользователи и задачи, — можно создать для каждой из них собственную директорию:

**Пример 9**. _Структура проекта с разделением логики_

```plaintext
src
├── redux
│   ├── store.js
│   ├── user
│   │   ├── slice.js
│   │   └── selectors.js
```

Такой подход называется feature-based organization (организация по функциональности), и он упрощает:

- поддержку и масштабирование проекта;
- повторное использование кода;
- понимание структуры даже при большом количестве модулей.
- работу в команде, когда разные разработчики могут работать над разными частями приложения.

[^1]: _Redux Toolkit_. redux-toolkit.js.org [online resource]. Available at: https://redux-toolkit.js.org/
[^2]: _Redux DevTools_. chromewebstore [online resource]. Available at: https://chromewebstore.google.com/detail/redux-devtools/lmhkpmbekcpmknklioeibfkpmmfibljd
