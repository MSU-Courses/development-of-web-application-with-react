# Глобальное управление состоянием в React. useContext

## Проблема локального состояния

В React-приложениях локальное состояние (через `useState` или `useReducer`, _о нем позже_) ограничено рамками одного компонента. Когда данные нужно поделиться с другими, особенно удалёнными по древу компонентами, разработчики сталкиваются с проблемой "прокидывания пропсов" (англ. _props drilling_).

_Прокидывание пропсов_ означает передачу состояния через несколько уровней вложенных компонентов посредством пропсов, даже если промежуточные компоненты сами напрямую эти данные не используют. _Такой подход быстро становится громоздким и неудобным_.

_Например_, чтобы передать тему оформления или данные текущего пользователя глубоко вложенному компоненту, приходится добавлять соответствующие пропсы на каждом уровне иерархии, что усложняет поддержку кода.

Почему же **локального состояния недостаточно**? Если разные части приложения должны обращаться к одним и тем же данным, невозможно просто определить их локально в одном компоненте — придётся либо дублировать состояние (что чревато рассинхронизацией), либо поднимать его выше в дерево и передавать вниз через пропсы. В крупных приложениях такой **prop drilling** ведёт к запутанному коду и ошибкам. Здесь на помощь приходит механизм глобального состояния — общее хранилище данных, доступное любому компоненту приложения.

Рассмотрим пример приложения — блога, имеющего структуру компонентов представленную схематично (см. **Схему 1**, см. **Рисунок 1**).

**Схема 1**. _Структура компонентов блога_

```plaintext
<App />
   ├── <Header />
   ├── <ProfilePage />
   │     └── <ProfileForm />   # Форма для изменения профиля
   │         └── <TextInput /> # Поле ввода имени пользователя
```

**Рисунок 1**. _Структура компонентов блога_

<img src="https://imgur.com/g8RC79Y.png" width="650" />

Перед нами стоит следующая задача: необходимо при изменении `<TextInput />` (имя пользователя), менять имя пользователя в `<Header />`. Это можно сделать с помощью локальных состтояний и _прокидывания пропсов_.

**Cхема 2**. _Прокидывание пропсов_

```plaintext
<App />
   ├── <Header username={username} />
   ├── <ProfilePage />
   │     └── <ProfileForm onChange={setUsername} />   # Форма для изменения профиля
   │         └── <TextInput value={username} /> # Поле ввода имени пользователя
```

**Рисунок 2**. _Прокидывание пропсов_

<img src="https://imgur.com/UW8Lp4b.png" width="650" />

В этом примере мы передаём `username` и `setUsername` через пропсы от `<App />` к `<Header />`, а затем от `<ProfileForm />` к `<TextInput />`. Данные буквально "прокладываются" через несколько уровней вложенности, что делает код сложным для понимания и поддержки. Если в будущем потребуется изменить структуру компонентов или добавить новые, это может привести к необходимости переписывать множество пропсов.

Здесь на помощь приходит механизм **глобального состояния** — общее хранилище данных, доступное любому компоненту приложения.

**Рисунок 3**. _Использование глобального состояния_

<img src="https://imgur.com/kmUp3ZZ.png" width="650" />

При таком подходе данные не передаются через пропсы, а записываются в глобальное состояние одним компонентом и считываются другим. Это позволяет избежать избыточного кода и упростить поддержку приложения.

Примером глобального состояния может служить тема приложения, настройки локализации, данные авторизованного пользователя и т.п. Эти данные можно считать «глобальными» для всего дерева компонентов​, и их удобнее хранить в одном месте, откуда любой компонент сможет их получить при необходимости.

Рассмотрим основные подходы к глобальному управлению состоянием в React:

- _Context API_ (встроенный в React инструмент)
- Внешний инструмент _Redux Toolkit_

А также их применение для асинхронных запросов.

## React Context API

**React Context** – это встроенный API React, позволяющий передавать данные через всё дерево компонентов без явной передачи пропсов на каждом уровне. Иными словами, контекст предоставляет глобальную переменную (или несколько), которую могут «подписываться» любые компоненты, минуя промежуточные звенья. Это особенно полезно для данных, которые нужны многим частям приложения: тема оформления, текущий язык, авторизация пользователя и пр. место того чтобы прокидывать такие данные через пропсы десяткам компонентов, можно создать контекст и один раз предоставить значение, доступное всем компонентам-потребителям этого контекста.

Документация React [^1] рекомендует использовать Context для данных, которые можно назвать глобальными для приложения (например, текущий аутентифицированный пользователь, UI-тема или язык интерфейса) и которые могут изменяться со временем. . В то же время не стоит использовать контекст для каждой мелкой задачи состояния – сначала лучше попробовать обойтись обычной передачей пропсов или поднятием состояния (_“lifting state up”_) до ближайшего общего предка. Контекст предназначен для случаев, когда пропсы уже перестают быть удобным решением.

### Реализация контексте

Для создания контекста используется функция `createContext()`, которая возвращает объект с двумя компонентами: `Provider` и `Consumer`. `Provider` используется для предоставления значения контекста, а `Consumer` — для его получения.

```js
createContext(defaultValue);
```

- `defaultValue` — значение, которое будет использоваться, если компонент не обернут в `Provider`. Это значение может быть любым типом данных: строкой, числом, объектом и т.д.

### Создание контекста

Предположим, нам нужно реализовать глобальное состояние для темы оформления приложения. Ниже приведён простой пример такой реализации.

**Пример 1**. _Создание контекста_

Файл `src/App.jsx`:

```js
import { useState } from 'react';
import Header from './components/Header';
// ...

// Создание контекста для Темы
// по умолчанию 'light'
export const ThemeContext = React.createContext();

const App = () => {
  const [theme, setTheme] = useState('light');

  return (
    <ThemeContext.Provider value={theme}>
      <Header />
      <Main />
    </ThemeContext.Provider>
  );
};

export default App;
```

Компоненты `Header` и `Main` теперь обёрнуты в `ThemeContext.Provider`, что позволяет передать текущее значение темы (в данном случае _'light'_) всем вложенным компонентам, которые подписаны на этот контекст.

### Использование контекста

Чтобы получить доступ к значению контекста в дочернем компоненте, необходимо импортировать `ThemeContext` и воспользоваться либо компонентом `ThemeContext.Consumer`, либо хуком `useContext`.

Хук `useContext` — это более современный и лаконичный способ, позволяющий получить значение контекста напрямую, без необходимости оборачивать JSX в `Consumer`. Он принимает объект контекста и возвращает его текущее значение.

**Пример 2**. _Использование контекста_

Файл `src/components/Header.jsx`:

```js
import React, { useContext } from 'react';
import { ThemeContext } from '../App';

const Header = () => {
  const theme = useContext(ThemeContext);

  return (
    <header className={theme}>
      <h1>My App</h1>
    </header>
  );
};

export default Header;
```

### Изменение контекста в дочернем компоненте

Вернёмся к примеру блога (см. _Схему 1_, _Рисунок 1_). В данной ситуации нам необходимо передать значение username из компонента `<TextInput />` в компонент `<Header />`. То есть нужно изменить имя пользователя в одном дочернем компоненте и отразить это изменение в другом, без явной передачи данных через пропсы.

Для этого мы передаём в контекст не только само значение username, но и функцию `setUsername`, позволяющую его изменять.

**Пример 3**. _Изменение значения контекста в дочернем компоненте_

Файл `src/App.jsx`:

```js
import { useState } from 'react';

import Header from './components/Header';
import ProfilePage from './components/ProfilePage';

// Создаём контекст для имени пользователя.
// Значение по умолчанию — null.
export const UserContext = React.createContext(null);

function App() {
  // В реальном приложении имя пользователя может загружаться с сервера
  const [username, setUsername] = useState('John Doe');

  return (
    <UserContext.Provider value={{ username, setUsername }}>
      <Header />
      <ProfilePage />
    </UserContext.Provider>
  );
}

export default App;
```

Файл `src/TextInput.jsx`:

```js
import React, { useContext } from 'react';

import { UserContext } from '../App';

const TextInput = () => {
  const { username, setUsername } = useContext(UserContext);

  return <input type="text" value={username} onChange={(e) => setUsername(e.target.value)} />;
};

export default TextInput;
```

Файл `src/Header.jsx`:

```js
import React, { useContext } from 'react';

import { UserContext } from '../App';

const Header = () => {
  const { username } = useContext(UserContext);

  return (
    <header>
      <h1>My App</h1>
      <p>Welcome, {username}!</p>
    </header>
  );
};

export default Header;
```

Теперь, когда пользователь изменяет своё имя в поле ввода (`<TextInput />`), оно автоматически отображается в заголовке (`<Header />`), поскольку оба компонента подписаны на одно и то же значение из контекста.

### Использование отдельного компонента для контекста

Вместо создания и управления контекстом непосредственно в файле `App.jsx`, его можно вынести в отдельный модуль. Такой подход особенно полезен в масштабируемых проектах, где контекст используется в различных частях приложения.

> [!NOTE]
> Обычно компонент, предоставляющий контекст, называют с суффиксом `Provider`, чтобы сразу было понятно, что он оборачивает другие компоненты и делится значениями.

**Пример 4**. _Выделение контекста в отдельный модуль_

Файл `src/contexts/UserContext.jsx`:

```js
import React, { createContext, useState } from 'react';

// Создаём контекст для имени пользователя
export const UserContext = createContext(null);

// Компонент-провайдер, оборачивающий дочерние компоненты
export const UserProvider = ({ children }) => {
  const [username, setUsername] = useState('John Doe');

  return <UserContext.Provider value={{ username, setUsername }}>{children}</UserContext.Provider>;
};
```

Файл `src/App.jsx`:

```js
import Header from './components/Header';
// ...

import { UserProvider } from './contexts/UserContext';

function App() {
  return (
    <UserProvider>
      <Header />
      <ProfilePage />
    </UserProvider>
  );
}

export default App;
```

Файлы: `src/components/Header.jsx` и `src/components/TextInput.jsx`:

Единственное изменение, которое необходимо внести — обновить путь импорта контекста:

```js
import { UserContext } from '../contexts/UserContext';
```

### Оптимизация повторных рендеров при передачи объектов в контексте

Когда в контекст передаётся объект, например `{ username, setUsername }`, React будет вызывать повторный рендер всех компонентов, подписанных на этот контекст, при каждом изменении объекта, даже если отдельные значения внутри него не изменились. Это связано с тем, что в JavaScript каждый раз создаётся новый объект — а значит, изменяется и ссылка, по которой React отслеживает изменения.

В небольших приложениях подобное поведение не вызывает заметных проблем (как в примерах, рассмотренных ранее). Однако в более масштабных проектах с множеством компонентов-подписчиков это может привести к избыточным ререндерам и, как следствие, к ухудшению производительности.

Чтобы избежать этого, можно использовать хук `useMemo` — он позволяет мемоизировать объект, передаваемый в контекст, и тем самым гарантировать, что ссылка на объект изменяется только при изменении его содержимого.

**Пример 5**. _Оптимизация повторных рендеров при передаче объектов в контекст_

Файл `src/contexts/UserContext.jsx`:

```js
import React, { createContext, useState, useMemo } from 'react';

// Создаём контекст для имени пользователя
export const UserContext = createContext(null);

// Провайдер, обеспечивающий доступ к значению контекста
export const UserProvider = ({ children }) => {
  const [username, setUsername] = useState('John Doe');

  // Мемоизация передаваемого объекта
  const value = useMemo(() => ({ username, setUsername }), [username]);

  return <UserContext.Provider value={value}>{children}</UserContext.Provider>;
};
```

Теперь, если значение username не изменилось, ссылка на объект `value` остаётся той же, и React не вызывает повторный рендер компонентов, использующих этот контекст. Это особенно важно в ситуациях, когда:

- контекст используется во множестве компонентов;
- дерево компонентов глубокое или содержит тяжёлые в отрисовке элементы;
- важно минимизировать ненужные вычисления или обращения к внешним данным.

> [!NOTE]
> Контекст часто используется в связке с хуком `useReducer`, который особенно полезен в более сложных приложениях.
>
> В отличие от `useState`, `useReducer` позволяет централизованно управлять состоянием, используя шаблон _"диспетчер-действие"_. Это способствует разделению логики обновления состояния и его представления, делая код чище, предсказуемее и удобнее для масштабирования.
>
> Такой подход хорошо подходит, когда у компонента есть множество связанных состояний или сложные сценарии изменения данных.
>
> Подробнее ознакомиться с `useReducer` можно в [документации React](https://react.dev/reference/react/useReducer).

### Плюсы и минусы Context API

Как инструмент глобального состояния, Context API имеет сильные стороны и ограничения:

| Плюсы                                                                                                                                                                  | Минусы                                                                                                                                                                                                                                                                                |
| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Встроен в React – не требует дополнительных зависимостей или настройки. Можно начать пользоваться контекстом в любом приложении из коробки.                            | Производительность – при обновлении значения контекста перерисовываются все потребители этого контекста. Если вы храните в одном контексте крупный объект состояния, малейшее изменение любого поля приведёт к обновлению всех компонентов, использующих хотя бы часть этого объекта. |
| Простота концепции – контекст передаёт значение всем вложенным компонентам. Это упрощает код по сравнению с многократной передачей пропсов.                            | Отсутствие встроенных средств отладки и расширений – в отличие от Redux, для Context API нет официальных DevTools, middleware                                                                                                                                                         |
| Гибкость – можно создавать сколь угодно много отдельных контекстов для разных типов данных (например, отдельный контекст для темы, отдельный для пользователя и т.д.). | Бо́льшая связанность компонентов – компоненты, которые используют контекст напрямую через `useContext`, становятся неявно зависимы от внешнего провайдера. В тестировании или повторном использовании таких компонентов нужно не забывать обеспечить нужный провайдер.                 |

В итоге, Context API отлично подходит для относительно простых случаев глобального состояния. Например, хранение темы оформления, флагов доступа, пользовательских настроек, или даже для управления состоянием небольшого модуля приложения. Он избавляет от необходимости передавать пропсы через всю иерархию и не требует подключения сторонних библиотек.

[^1]: _useContext_. react.dev [online resource]. Available at: https://react.dev/reference/react/useContext
